<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>構造体 sxsdk::shape_class</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- 作成： Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="namespaces.html"><span>ネームスペース</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>構成</span></a></li>
      <li><a href="hierarchy.html"><span>クラス階層</span></a></li>
      <li><a href="functions.html"><span>構成メンバ</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacesxsdk.html">sxsdk</a>::<a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>
  </div>
</div>
<div class="contents">
<h1>構造体 sxsdk::shape_class</h1><!-- doxytag: class="sxsdk::shape_class" --><div class="dynheader">
sxsdk::shape_classに対する継承グラフ</div>
<div class="dynsection">
 <div class="center">
  <img src="structsxsdk_1_1shape__class.gif" usemap="#sxsdk::shape_class_map" alt=""/>
  <map id="sxsdk::shape_class_map" name="sxsdk::shape_class_map">
<area href="structsxsdk_1_1disk__class.html" alt="sxsdk::disk_class" shape="rect" coords="182,56,354,80"/>
<area href="structsxsdk_1_1light__class.html" alt="sxsdk::light_class" shape="rect" coords="182,112,354,136"/>
<area href="structsxsdk_1_1line__class.html" alt="sxsdk::line_class" shape="rect" coords="182,168,354,192"/>
<area href="structsxsdk_1_1master__image__class.html" alt="sxsdk::master_image_class" shape="rect" coords="182,224,354,248"/>
<area href="structsxsdk_1_1master__surface__class.html" alt="sxsdk::master_surface_class" shape="rect" coords="182,280,354,304"/>
<area href="structsxsdk_1_1part__class.html" alt="sxsdk::part_class" shape="rect" coords="182,336,354,360"/>
<area href="structsxsdk_1_1polygon__mesh__class.html" alt="sxsdk::polygon_mesh_class" shape="rect" coords="182,392,354,416"/>
<area href="structsxsdk_1_1proxy__shape__class.html" alt="sxsdk::proxy_shape_class" shape="rect" coords="182,448,354,472"/>
<area href="structsxsdk_1_1sentinel__class.html" alt="sxsdk::sentinel_class" shape="rect" coords="182,504,354,528"/>
<area href="structsxsdk_1_1sphere__class.html" alt="sxsdk::sphere_class" shape="rect" coords="182,560,354,584"/>
</map>
 </div>
</div>

<p><a href="structsxsdk_1_1shape__class-members.html">すべてのメンバ一覧</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>構成</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsxsdk_1_1shape__class_1_1const__iterator.html">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsxsdk_1_1shape__class_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsxsdk_1_1shape__class_1_1iterator.html">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsxsdk_1_1shape__class_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2>Public メソッド</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1scene__interface.html">sxsdk::scene_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a476057cf7e7c4797c0c5b5c41dc347b9">get_scene_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状が属するシーンを取得する。  <a href="#a476057cf7e7c4797c0c5b5c41dc347b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d4bb2e10d8cbbca4b3c512be3912898"></a><!-- doxytag: member="sxsdk::shape_class::get_surface_interface" ref="a1d4bb2e10d8cbbca4b3c512be3912898" args="(void *=0) const " -->
virtual test <a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_surface_interface</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1motion__interface.html">sxsdk::motion_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa">get_motion_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1motion__interface.html">motion_interface</a></code> を取得する。  <a href="#abfee2d534fcf9944b649873b51f7edfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a235917324e86d9cfebf7ed6e13e887ce">get_bro</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">次の形状を取得する。  <a href="#a235917324e86d9cfebf7ed6e13e887ce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a46e765a64702e7a1ccce6b51bbc5512e">get_sis</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">前の形状を取得する。  <a href="#a46e765a64702e7a1ccce6b51bbc5512e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a010a77dcc709ad5531a274c790daa907">get_dad</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">親の形状を取得する。  <a href="#a010a77dcc709ad5531a274c790daa907"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aab98263026c91dd4ce31cbc69748aefa">get_son</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">子の番兵形状(<code><a class="el" href="structsxsdk_1_1sentinel__class.html">sentinel_class</a></code> を参照)を取得する。  <a href="#aab98263026c91dd4ce31cbc69748aefa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae2c3e3c08b3bf23288e516b2686fd6e9"></a><!-- doxytag: member="sxsdk::shape_class::get_type" ref="ae2c3e3c08b3bf23288e516b2686fd6e9" args="(void *=0) const " -->
virtual <a class="el" href="namespacesxsdk_1_1enums.html#aa6cc70b74636bfbf63bbfb8a2da2ce52">enums::shape_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9">get_type</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状の種類 (<code><a class="el" href="namespacesxsdk_1_1enums.html#aa6cc70b74636bfbf63bbfb8a2da2ce52" title="形状の種類">enums::shape_type</a></code> を参照)を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a31fd0b8c9cb642a87b37aaed58cf322d">get_handle</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状のハンドルを取得する。  <a href="#a31fd0b8c9cb642a87b37aaed58cf322d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f71654df3e219aabe18b11465000d07"></a><!-- doxytag: member="sxsdk::shape_class::get_color_obsolete" ref="a6f71654df3e219aabe18b11465000d07" args="(void *aux=0)" -->
virtual sxsdk::rgb_class&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_color_obsolete</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5607aa247b827c049952933673bc41a2"></a><!-- doxytag: member="sxsdk::shape_class::is_one_of_active_shapes" ref="a5607aa247b827c049952933673bc41a2" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5607aa247b827c049952933673bc41a2">is_one_of_active_shapes</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状が選択されているかか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a40fb84dcfb17b83ca6b1ddb521de0737">begin</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">下位階層の最初の形状のイテレータを取得する。  <a href="#a40fb84dcfb17b83ca6b1ddb521de0737"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1iterator.html">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7a5b031257e482c32cb306a47244bc6d">end</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">下位階層の最後の形状(番兵形状)のイテレータを取得する。  <a href="#a7a5b031257e482c32cb306a47244bc6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a735bfaceb1406c4d00d9972d97184a9b"></a><!-- doxytag: member="sxsdk::shape_class::get_transformation" ref="a735bfaceb1406c4d00d9972d97184a9b" args="(void *=0) const " -->
virtual sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a735bfaceb1406c4d00d9972d97184a9b">get_transformation</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状の変換マトリクスを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1a7bc16788d829d9f233abcf4d841477">get_number_of_points</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ポイントの数を取得する。  <a href="#a1a7bc16788d829d9f233abcf4d841477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68038e70c2a8ecfa9daf38f15e69e06d"></a><!-- doxytag: member="sxsdk::shape_class::get_point" ref="a68038e70c2a8ecfa9daf38f15e69e06d" args="(int i, void *aux=0)" -->
virtual sxsdk::vec3&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_point</b> (int i, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abdb6442108856d412cf31f1149a39a0c"></a><!-- doxytag: member="sxsdk::shape_class::set_point" ref="abdb6442108856d412cf31f1149a39a0c" args="(int i, const sxsdk::vec3 &amp;v, void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_point</b> (int i, const sxsdk::vec3 &amp;v, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7afcd59713aa04be787b73667aed96b2">set_name</a> (const char *name_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状の名前を設定する。  <a href="#a7afcd59713aa04be787b73667aed96b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4b4993a71180f51b1ddc66cad131cf57">get_name</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状の名前を取得する。  <a href="#a4b4993a71180f51b1ddc66cad131cf57"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a74393c305bca1e6b397d9ceff2e52127">set_extrude</a> (const sxsdk::vec3 &amp;extrude_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">掃引の方向と距離を設定する。  <a href="#a74393c305bca1e6b397d9ceff2e52127"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual sxsdk::vec3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#adfd66a3363fc9415a4ca8982c467b48c">get_extrude</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">掃引の方向と距離を取得する。  <a href="#adfd66a3363fc9415a4ca8982c467b48c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d">set_revolve_from</a> (float revolve_from_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の開始角度(ラジアン)を設定する。  <a href="#a3ae19dcf3327e1e1bed5ca02b59eb07d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b">get_revolve_from</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の開始角度(ラジアン)を取得する。  <a href="#ae019a1a3be32d6615f4c4f5e71a01b1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e">set_revolve_to</a> (float revolve_to_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の終了角度(ラジアン)を設定する。  <a href="#accef93bfb10d51f2e25f013055fc9f4e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792">get_revolve_to</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の終了角度(ラジアン)を取得する。  <a href="#a9ec29179a5703dc9140a835855714792"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af92798001c64f08ba15229a26bdf1be0"></a><!-- doxytag: member="sxsdk::shape_class::get_has_surface_attributes" ref="af92798001c64f08ba15229a26bdf1be0" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#af92798001c64f08ba15229a26bdf1be0">get_has_surface_attributes</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状が表面材質を持っているかどうかを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81c5012feb3f20e584ac7b7faa58b972"></a><!-- doxytag: member="sxsdk::shape_class::set_has_surface_attributes" ref="a81c5012feb3f20e584ac7b7faa58b972" args="(bool has_surface_attributes_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a81c5012feb3f20e584ac7b7faa58b972">set_has_surface_attributes</a> (bool has_surface_attributes_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状が表面材質を持っているかどうかを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27430d710055601b9eb7c392b34f476d"></a><!-- doxytag: member="sxsdk::shape_class::set_has_diffuse_color_deprecated" ref="a27430d710055601b9eb7c392b34f476d" args="(bool has_diffuse_color_deprecated_param, void *=0)" -->
virtual test <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_has_diffuse_color_deprecated</b> (bool has_diffuse_color_deprecated_param, void *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab36518575603eef32d958ad5410f09ba"></a><!-- doxytag: member="sxsdk::shape_class::get_has_diffuse_color_deprecated" ref="ab36518575603eef32d958ad5410f09ba" args="(void *=0) const " -->
virtual test bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_has_diffuse_color_deprecated</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ea9eb77d2f89d81ac486b0401fcda9f"></a><!-- doxytag: member="sxsdk::shape_class::set_base_color_deprecated" ref="a8ea9eb77d2f89d81ac486b0401fcda9f" args="(const sxsdk::rgb_class &amp;color, void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_base_color_deprecated</b> (const sxsdk::rgb_class &amp;color, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43527b8714a745d9b206e5e4822712aa"></a><!-- doxytag: member="sxsdk::shape_class::get_diffuse_color_deprecated" ref="a43527b8714a745d9b206e5e4822712aa" args="(void *=0) const " -->
virtual test sxsdk::rgb_class&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_diffuse_color_deprecated</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a44a2eb909f4ec9f0294efa201c8fab23">set_master_surface</a> (<a class="el" href="structsxsdk_1_1master__surface__class.html">sxsdk::master_surface_class</a> *master_surface_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">マスターサーフェスの適用を設定する。  <a href="#a44a2eb909f4ec9f0294efa201c8fab23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8cea6fa4f951b1e38b3c3eed4d5c80c"></a><!-- doxytag: member="sxsdk::shape_class::get_master_surface" ref="ae8cea6fa4f951b1e38b3c3eed4d5c80c" args="(void *=0) const " -->
virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1master__surface__class.html">sxsdk::master_surface_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae8cea6fa4f951b1e38b3c3eed4d5c80c">get_master_surface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">マスターサーフェスの適用を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1part__class.html">part_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae0edc8f16bac8ec43b69f58ff044f5d1">get_part</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1part__class.html">part_class</a></code> を取得する(<code>const</code> )。形状の種類がパートではない場合は例外を投げる。  <a href="#ae0edc8f16bac8ec43b69f58ff044f5d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#af549ebc37d1f503cdd1426eb06f27fa3">get_part</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1part__class.html">part_class</a></code> を取得する。形状の種類がパートではない場合は例外を投げる。  <a href="#af549ebc37d1f503cdd1426eb06f27fa3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1line__class.html">line_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1ed3df762f1392e0da364de8acdbd9ca">get_line</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1line__class.html">line_class</a></code> を取得する(<code>const</code> )。形状の種類が線形状ではない場合は例外を投げる。  <a href="#a1ed3df762f1392e0da364de8acdbd9ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1line__class.html">line_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a07dc7fc7cc70e6e3b9c19ce69c1b30d8">get_line</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1line__class.html">line_class</a></code> を取得する。形状の種類が線形状ではない場合は例外を投げる。  <a href="#a07dc7fc7cc70e6e3b9c19ce69c1b30d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa13d4845d8554178d6987c97f33f9e8c">get_polygon_mesh</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a></code> を取得する(<code>const</code> )。形状の種類がポリゴンメッシュではない場合は例外を投げる。  <a href="#aa13d4845d8554178d6987c97f33f9e8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4a770995862b16960db2e4ff23696606">get_polygon_mesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a></code> を取得する。形状の種類がポリゴンメッシュではない場合は例外を投げる。  <a href="#a4a770995862b16960db2e4ff23696606"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9db10f634448547fe9495a6542b0efa9">get_disk</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a></code> を取得する(<code>const</code> )。形状の種類が円ではない場合は例外を投げる。  <a href="#a9db10f634448547fe9495a6542b0efa9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aece36cf8036180cf0ab1b547dc6c27dd">get_disk</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a></code> を取得する。形状の種類が円ではない場合は例外を投げる。  <a href="#aece36cf8036180cf0ab1b547dc6c27dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aceadb2af17ec5109c915c748aa034a24">get_sphere</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a></code> を取得する(<code>const</code> )。形状の種類が球ではない場合は例外を投げる。  <a href="#aceadb2af17ec5109c915c748aa034a24"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac360965b29d587204e1bed5262ce690f">get_sphere</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a></code> を取得する。形状の種類が球ではない場合は例外を投げる。  <a href="#ac360965b29d587204e1bed5262ce690f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1light__class.html">light_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad60f242552772ddfa94c585e7280d3ca">get_light</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1light__class.html">light_class</a></code> を取得する(<code>const</code> )。形状の種類が光源ではない場合は例外を投げる。  <a href="#ad60f242552772ddfa94c585e7280d3ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1light__class.html">light_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aba4f429608de18d7100470bbc3e7879f">get_light</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1light__class.html">light_class</a></code> を取得する。形状の種類が光源ではない場合は例外を投げる。  <a href="#aba4f429608de18d7100470bbc3e7879f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual sxsdk::vec3&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0f47b71f6e19eebdbd262d5946d5a168">get_center_point</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">中心の座標値を取得する。  <a href="#a0f47b71f6e19eebdbd262d5946d5a168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8f6c4c8a6e1a288c3a932bb8b9828784">get_local_to_world_matrix</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ローカル座標系からワールド座標系への変換マトリクスを取得する。  <a href="#a8f6c4c8a6e1a288c3a932bb8b9828784"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad3c84cbdc78f1b5b827d8aa80136b056">get_world_to_local_matrix</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ワールド座標系からローカル座標系への変換マトリクスを取得する。  <a href="#ad3c84cbdc78f1b5b827d8aa80136b056"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6f6ddd02a66777a27253dfebf2be2893">transform</a> (const sxsdk::mat4 &amp;matrix, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状にマトリクス変換をかける。  <a href="#a6f6ddd02a66777a27253dfebf2be2893"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac92ae88654791460459a1795842a940b">has_surface</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">表面材質を持っているかどうか  <a href="#ac92ae88654791460459a1795842a940b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a840a0bd2103ee51e8e579e928ed38e55">has_motion</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">モーションを設定できる形状を持っているか判定する。  <a href="#a840a0bd2103ee51e8e579e928ed38e55"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a30e22aa4205d3661c64182650bd6f0ad">has_bro</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">次の形状を持っているか判定する。  <a href="#a30e22aa4205d3661c64182650bd6f0ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8f0b3077baa9d8a149629d5447566ad0">has_sis</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">前の形状を持っているか判定する。  <a href="#a8f0b3077baa9d8a149629d5447566ad0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ada131e151bf013510d11ab8f891c31c8">has_dad</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">親の形状を持っているか判定する。  <a href="#ada131e151bf013510d11ab8f891c31c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a114c71dbb4d26d3ecf95a48a7e610644">has_son</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">（番兵でない）子の形状を持っているか判定する。  <a href="#a114c71dbb4d26d3ecf95a48a7e610644"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad312020e9daa1c3b8a23a04bae02da3d"></a><!-- doxytag: member="sxsdk::shape_class::remove" ref="ad312020e9daa1c3b8a23a04bae02da3d" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad312020e9daa1c3b8a23a04bae02da3d">remove</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を削除する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa42b478384b94d85bc3fdc180878387d">is_extruded</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">掃引体かどうかか判定する。  <a href="#aa42b478384b94d85bc3fdc180878387d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2">is_revolved</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体かどうかか判定する。  <a href="#a5efe1dfae7d7d5e55c70c1e9ea0f95d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a010d4f7ee04996674701c479cc9e8fb3">get_axis_matrix</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の軸を定義するマトリクスを取得する。  <a href="#a010d4f7ee04996674701c479cc9e8fb3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72eb3627fea66a6557fae36d3957aaa9"></a><!-- doxytag: member="sxsdk::shape_class::set_flip_face" ref="a72eb3627fea66a6557fae36d3957aaa9" args="(bool flip_face_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a72eb3627fea66a6557fae36d3957aaa9">set_flip_face</a> (bool flip_face_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">面が反転されているかどうかを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6af2471b084f3865143805dac7277d49"></a><!-- doxytag: member="sxsdk::shape_class::get_flip_face" ref="a6af2471b084f3865143805dac7277d49" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6af2471b084f3865143805dac7277d49">get_flip_face</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">面が反転されているかどうかを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a63db5b00d013ef2a50482f723488bbf9">get_total_number_of_control_points</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">コントロールポイントの総数を取得する。  <a href="#a63db5b00d013ef2a50482f723488bbf9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18e2f1937522a93dddc9ac38c7c08e2b"></a><!-- doxytag: member="sxsdk::shape_class::cancel_transformation" ref="a18e2f1937522a93dddc9ac38c7c08e2b" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a18e2f1937522a93dddc9ac38c7c08e2b">cancel_transformation</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">変換の相殺を行う。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd5a7e9aeeaaf67121bfc7d745bf1ab5"></a><!-- doxytag: member="sxsdk::shape_class::convert_to_mesh_obsolete" ref="acd5a7e9aeeaaf67121bfc7d745bf1ab5" args="(int m=0, int n=0, void *aux=0)" -->
virtual <a class="el" href="structsxsdk_1_1mesh__interface.html">mesh_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>convert_to_mesh_obsolete</b> (int m=0, int n=0, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae1cb82a7dcc409f4a96ce3146167bfe5"></a><!-- doxytag: member="sxsdk::shape_class::create_attribute_stream_interface" ref="ae1cb82a7dcc409f4a96ce3146167bfe5" args="(int stream_id, int wireframe_id=0, int intersection_id=0, void *aux=0)" -->
virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>create_attribute_stream_interface</b> (int stream_id, int wireframe_id=0, int intersection_id=0, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac81d733533993740f975aa9336a91a40"></a><!-- doxytag: member="sxsdk::shape_class::get_attribute_stream_interface" ref="ac81d733533993740f975aa9336a91a40" args="(int stream_id, void *aux=0)" -->
virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_attribute_stream_interface</b> (int stream_id, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac8459ffbb0bfac14fba6361736a6fb9d">make_sphere_wireframe</a> (const sxsdk::mat4 &amp;mat, const sxsdk::mat4 &amp;trans, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">球のワイヤーフレームを作成する。  <a href="#ac8459ffbb0bfac14fba6361736a6fb9d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac02ee44513cc99bc33ee281562a7a57d">set_axis_matrix</a> (const sxsdk::mat4 &amp;to, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体の軸を定義するマトリクスを設定する。  <a href="#ac02ee44513cc99bc33ee281562a7a57d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae2bde59792a6745f03cd3705ca416484">get_ordinal</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状／パートの序数を取得する。  <a href="#ae2bde59792a6745f03cd3705ca416484"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a89bfca3a6363939b53ee036561d064e8">set_surface</a> (<a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a> *surface, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a></code> から表面材質を適用する。  <a href="#a89bfca3a6363939b53ee036561d064e8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#af8f6cc4c74b70b22294803425ebd9f06">make_line_wireframe</a> (const sxsdk::mat4 &amp;mat, int n, const sxsdk::vec3 *p, bool closed=false, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">線のワイヤーフレームを作成する。  <a href="#af8f6cc4c74b70b22294803425ebd9f06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae079ebec09405d7a516da575a9846cfc"></a><!-- doxytag: member="sxsdk::shape_class::update" ref="ae079ebec09405d7a516da575a9846cfc" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae079ebec09405d7a516da575a9846cfc">update</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を更新する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a3c3da530b8f065de1388404d4e292188">begin_set_point</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ワイヤーフレームの更新を一時的に停止する。  <a href="#a3c3da530b8f065de1388404d4e292188"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493">end_set_point</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ワイヤーフレームの更新を再開する。  <a href="#a2e019b101dff70fefbb66f679865a493"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a86eb2f9b77ea5dcf307451c87d594be7">show</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を表示する。  <a href="#a86eb2f9b77ea5dcf307451c87d594be7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a616f7a8f37733b0f1a2aa70e90dfe34c">hide</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を隠す。  <a href="#a616f7a8f37733b0f1a2aa70e90dfe34c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e02cfdde6769740eb06b5bc88995ce"></a><!-- doxytag: member="sxsdk::shape_class::delete_attribute" ref="ab9e02cfdde6769740eb06b5bc88995ce" args="(int id, void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>delete_attribute</b> (int id, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa3e2ebdc5147f4345a57147369bb852a">place_parent</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状をn階層上に移動する。  <a href="#aa3e2ebdc5147f4345a57147369bb852a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a729fe7fa976bda3543b2529a366a0aac">place_child</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を1階層下のn番目の位置に移動する。  <a href="#a729fe7fa976bda3543b2529a366a0aac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a96c8173631adbdf454534debbbdc855e">place_brother</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状をn個後に移動する。  <a href="#a96c8173631adbdf454534debbbdc855e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6b79d73557adbd8decc1019eee838ff2">place_sister</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状をn個前に移動する。  <a href="#a6b79d73557adbd8decc1019eee838ff2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa4af76b72ae4cd6902f19a4d1ec6157a">place</a> (<a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;at, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を挿入点の後に移動する。  <a href="#aa4af76b72ae4cd6902f19a4d1ec6157a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6bc0d061be07df7acd91ecb9445b7904"></a><!-- doxytag: member="sxsdk::shape_class::get_shape_interface" ref="a6bc0d061be07df7acd91ecb9445b7904" args="(void *aux=0)" -->
virtual shape_interface *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_shape_interface</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9a8b6fb3c1caa13dbad6ef3b9fe4ff9"></a><!-- doxytag: member="sxsdk::shape_class::copy" ref="aa9a8b6fb3c1caa13dbad6ef3b9fe4ff9" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa9a8b6fb3c1caa13dbad6ef3b9fe4ff9">copy</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状をクリップボードにコピーする。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae92d708466560b51a0512c51edb8380d"></a><!-- doxytag: member="sxsdk::shape_class::paste" ref="ae92d708466560b51a0512c51edb8380d" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae92d708466560b51a0512c51edb8380d">paste</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状をクリップボードからペーストする。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba1ec18d79aae7e730d39fde6724d7c3"></a><!-- doxytag: member="sxsdk::shape_class::is_switched" ref="aba1ec18d79aae7e730d39fde6724d7c3" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aba1ec18d79aae7e730d39fde6724d7c3">is_switched</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">自由曲面の縦横が切り替えられたかどうかか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9bad0cd487e7a691dfd16f962b9d571d">copy_object</a> (const sxsdk::mat4 &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を複製する。  <a href="#a9bad0cd487e7a691dfd16f962b9d571d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8073a774415254611695f128a24dc1fb">move_object</a> (const sxsdk::mat4 &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を移動する。  <a href="#a8073a774415254611695f128a24dc1fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac24c5fb2a55241e535e9c77ac807a255"></a><!-- doxytag: member="sxsdk::shape_class::is_shown" ref="ac24c5fb2a55241e535e9c77ac807a255" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac24c5fb2a55241e535e9c77ac807a255">is_shown</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状が表示されているかどうかか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4e5d5e3e0294b757a6f2255c23676a69"></a><!-- doxytag: member="sxsdk::shape_class::get_diffuse_value_deprecated" ref="a4e5d5e3e0294b757a6f2255c23676a69" args="(void *=0) const " -->
virtual test float&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_diffuse_value_deprecated</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a2b856c27eea2c6b9503fd9a50fcd3"></a><!-- doxytag: member="sxsdk::shape_class::set_diffuse_value_deprecated" ref="a81a2b856c27eea2c6b9503fd9a50fcd3" args="(float diffuse_value_deprecated_param, void *=0)" -->
virtual test <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_diffuse_value_deprecated</b> (float diffuse_value_deprecated_param, void *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad0de7cd623ba32641ccee2c29041f37b">solid_extrude</a> (const sxsdk::vec3 &amp;by, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">掃引体を作成する。  <a href="#ad0de7cd623ba32641ccee2c29041f37b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2865369d7be91398c7897c1d43bbb4ac">solid_revolve</a> (const sxsdk::vec3 &amp;v0, const sxsdk::vec3 &amp;v1, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転体を作成する。  <a href="#a2865369d7be91398c7897c1d43bbb4ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aad9db70faddfb7956a8a88b6101b314c">solid_clear</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">掃引体、回転体を通常の形状に復帰する。  <a href="#aad9db70faddfb7956a8a88b6101b314c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4cc25c898d21d4b577adf1f9673c81c4">reset_transformation</a> (bool deep=false, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">変換マトリクスをリセットする。  <a href="#a4cc25c898d21d4b577adf1f9673c81c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1meshes__interface.html">meshes_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aaf8cec2c65adb28e0e9f52b4b1671a32">create_converted_meshes_interface</a> (int level=2, int texture=0, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">メッシュに変換したテンポラリ形状を生成する。  <a href="#aaf8cec2c65adb28e0e9f52b4b1671a32"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual polygon_mesh_interface *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0c070f8e8f26b3de7b3f6b9f5b219b90">create_converted_polygon_mesh_interface</a> (int level=2, int texture=0, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ポリゴンメッシュに変換したテンポラリ形状を生成する。  <a href="#a0c070f8e8f26b3de7b3f6b9f5b219b90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ada2c2d49a2ea17bc594fd8ac94627a69"></a><!-- doxytag: member="sxsdk::shape_class::adjust_transformation" ref="ada2c2d49a2ea17bc594fd8ac94627a69" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ada2c2d49a2ea17bc594fd8ac94627a69">adjust_transformation</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">変換マトリクスを調節する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ab724792f02a0b47fbe6dbf9e10ecc46d">get_modifiable</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状がモディファイ可能かどうかを取得する。  <a href="#ab724792f02a0b47fbe6dbf9e10ecc46d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a87ebbdb668ba95fcba4f111ab188a7dd">set_modifiable</a> (bool modifiable_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状がモディファイ可能かどうかを設定する。  <a href="#a87ebbdb668ba95fcba4f111ab188a7dd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac1778645b664c8cde2e69ed4d8aa87d3">get_browsable</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状がブラウザウインドウに表示可能かどうかを取得する。  <a href="#ac1778645b664c8cde2e69ed4d8aa87d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aeda4393c11d630541b26fbbc9aeef768">set_browsable</a> (bool browsable_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状がブラウザウインドウに表示可能かどうかを設定する。  <a href="#aeda4393c11d630541b26fbbc9aeef768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae617d8d3d40634a600ad5e8111490768">get_render_flag</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">レンダリング対象とするかどうかを取得する。  <a href="#ae617d8d3d40634a600ad5e8111490768"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0f94347bb8c1a087dc3d0e0188e64402">set_render_flag</a> (int render_flag_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">レンダリング対象とするかどうかを設定する。  <a href="#a0f94347bb8c1a087dc3d0e0188e64402"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a15be5f50617d9ba38272fb1cd35d1e5f">set_active_control_point</a> (int at, bool select, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定したコントロールポイントの選択状態を設定する。  <a href="#a15be5f50617d9ba38272fb1cd35d1e5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0c43f1db671eab28283519aa41262dfe">get_active_control_point</a> (int at, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定したコントロールポイントの選択状態を取得する。  <a href="#a0c43f1db671eab28283519aa41262dfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5a63ae8f64099f5f8f4c9eedbbffae3e">append_skin</a> (<a class="el" href="structsxsdk_1_1part__class.html">part_class</a> &amp;part, float weight=1.0, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スキン設定を追加する。  <a href="#a5a63ae8f64099f5f8f4c9eedbbffae3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad68676ad7de4541ffb326650fe6fc77a"></a><!-- doxytag: member="sxsdk::shape_class::clear_skin" ref="ad68676ad7de4541ffb326650fe6fc77a" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad68676ad7de4541ffb326650fe6fc77a">clear_skin</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スキンを解除する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac5e6ab61573cd4762f82bfa355877054"></a><!-- doxytag: member="sxsdk::shape_class::select" ref="ac5e6ab61573cd4762f82bfa355877054" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac5e6ab61573cd4762f82bfa355877054">select</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を選択する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2be45af5c9ad7ee90d512a5d6010caa"></a><!-- doxytag: member="sxsdk::shape_class::activate" ref="aa2be45af5c9ad7ee90d512a5d6010caa" args="(void *aux=0)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa2be45af5c9ad7ee90d512a5d6010caa">activate</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を選択する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a33aaa994f0920546c9ec78219e989408">select_all_control_points</a> (bool select, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">全てのコントロールポイントを選択／非選択する。  <a href="#a33aaa994f0920546c9ec78219e989408"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5591bef90d736888f698d072c1264b3c">is_control_point_selected</a> (int i, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">コントロールポイントが選択されているかどうか取得する。  <a href="#a5591bef90d736888f698d072c1264b3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6cf23f7315a27bb99ac241b56fe7f658"></a><!-- doxytag: member="sxsdk::shape_class::get_rendering_flag_obsolete" ref="a6cf23f7315a27bb99ac241b56fe7f658" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_rendering_flag_obsolete</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a517a2d2631549f5dce8eb609b1401c31"></a><!-- doxytag: member="sxsdk::shape_class::set_has_shadow_map_size" ref="a517a2d2631549f5dce8eb609b1401c31" args="(bool has_shadow_map_size_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a517a2d2631549f5dce8eb609b1401c31">set_has_shadow_map_size</a> (bool has_shadow_map_size_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_sizeの値が設定されているかどうかを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a45a27c9fc975bce266546f44cc32bf86"></a><!-- doxytag: member="sxsdk::shape_class::get_has_shadow_map_size" ref="a45a27c9fc975bce266546f44cc32bf86" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a45a27c9fc975bce266546f44cc32bf86">get_has_shadow_map_size</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_sizeの値が設定されているかどうかを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2865e5ac0ffa8e2ef9ef41e5ea3a6821"></a><!-- doxytag: member="sxsdk::shape_class::set_shadow_map_size" ref="a2865e5ac0ffa8e2ef9ef41e5ea3a6821" args="(int shadow_map_size_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2865e5ac0ffa8e2ef9ef41e5ea3a6821">set_shadow_map_size</a> (int shadow_map_size_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップのサイズを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a730fb54d909c3ce3b7e71e1396c0a5f9"></a><!-- doxytag: member="sxsdk::shape_class::get_shadow_map_size" ref="a730fb54d909c3ce3b7e71e1396c0a5f9" args="(void *=0) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a730fb54d909c3ce3b7e71e1396c0a5f9">get_shadow_map_size</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップのサイズを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad2b445f5c4f7e25a972dc2466d69d532"></a><!-- doxytag: member="sxsdk::shape_class::set_has_shadow_map_bias" ref="ad2b445f5c4f7e25a972dc2466d69d532" args="(bool has_shadow_map_bias_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad2b445f5c4f7e25a972dc2466d69d532">set_has_shadow_map_bias</a> (bool has_shadow_map_bias_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_biasの値が設定されているかどうかを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7aef1cd2069db24495ff6d8f9731d3cb"></a><!-- doxytag: member="sxsdk::shape_class::get_has_shadow_map_bias" ref="a7aef1cd2069db24495ff6d8f9731d3cb" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7aef1cd2069db24495ff6d8f9731d3cb">get_has_shadow_map_bias</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_biasの値が設定されているかどうかを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4256e252f12ae6a201e393431e06a2ed"></a><!-- doxytag: member="sxsdk::shape_class::set_shadow_map_bias" ref="a4256e252f12ae6a201e393431e06a2ed" args="(float shadow_map_bias_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4256e252f12ae6a201e393431e06a2ed">set_shadow_map_bias</a> (float shadow_map_bias_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップバイアス値を設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae3ea8bcb42c55efd3f567735413095ab"></a><!-- doxytag: member="sxsdk::shape_class::get_shadow_map_bias" ref="ae3ea8bcb42c55efd3f567735413095ab" args="(void *=0) const " -->
virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae3ea8bcb42c55efd3f567735413095ab">get_shadow_map_bias</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップバイアス値を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ddaead4dd97cba5fbea7f771d02e7c1"></a><!-- doxytag: member="sxsdk::shape_class::set_has_shadow_map_blur" ref="a6ddaead4dd97cba5fbea7f771d02e7c1" args="(bool has_shadow_map_blur_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6ddaead4dd97cba5fbea7f771d02e7c1">set_has_shadow_map_blur</a> (bool has_shadow_map_blur_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_blurの値が設定されているかどうかを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fd4badf4aa70e94cc5f51b488a0b4ef"></a><!-- doxytag: member="sxsdk::shape_class::get_has_shadow_map_blur" ref="a4fd4badf4aa70e94cc5f51b488a0b4ef" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4fd4badf4aa70e94cc5f51b488a0b4ef">get_has_shadow_map_blur</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">shadow_map_blurの値が設定されているかどうかを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a448fc0c431ae588d8efde706128d3000"></a><!-- doxytag: member="sxsdk::shape_class::set_shadow_map_blur" ref="a448fc0c431ae588d8efde706128d3000" args="(float shadow_map_blur_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a448fc0c431ae588d8efde706128d3000">set_shadow_map_blur</a> (float shadow_map_blur_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップブラーの値を設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9d6b3b2ef07288ff2c15fdb8e1d6b24"></a><!-- doxytag: member="sxsdk::shape_class::get_shadow_map_blur" ref="aa9d6b3b2ef07288ff2c15fdb8e1d6b24" args="(void *=0) const " -->
virtual float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa9d6b3b2ef07288ff2c15fdb8e1d6b24">get_shadow_map_blur</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウマップブラーの値を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7bc3ff645e3a5a1b7d39f09f644c04eb"></a><!-- doxytag: member="sxsdk::shape_class::set_shadow_type" ref="a7bc3ff645e3a5a1b7d39f09f644c04eb" args="(sxsdk::enums::shadow_type shadow_type_param, void *=0)" -->
virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7bc3ff645e3a5a1b7d39f09f644c04eb">set_shadow_type</a> (<a class="el" href="namespacesxsdk_1_1enums.html#a46793265982a4d41c5ebe543446871dc">sxsdk::enums::shadow_type</a> shadow_type_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウのタイプを設定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ec70a2c408fd024fc7abfee7bc385f1"></a><!-- doxytag: member="sxsdk::shape_class::get_shadow_type" ref="a0ec70a2c408fd024fc7abfee7bc385f1" args="(void *=0) const " -->
virtual <a class="el" href="namespacesxsdk_1_1enums.html#a46793265982a4d41c5ebe543446871dc">sxsdk::enums::shadow_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0ec70a2c408fd024fc7abfee7bc385f1">get_shadow_type</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウのタイプを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abaf6ed551e1e8fc484d146d6b6e355c3"></a><!-- doxytag: member="sxsdk::shape_class::get_error_string" ref="abaf6ed551e1e8fc484d146d6b6e355c3" args="(void *aux=0)" -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_error_string</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#adc1089a61be1db5de27c0ba324c53279">get_active_control_points</a> (int *p, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">選択されているコントロールポイントの番号のリストを取得する。  <a href="#adc1089a61be1db5de27c0ba324c53279"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0bb9bf8b7ec1295235cc9fb8a0809a34"></a><!-- doxytag: member="sxsdk::shape_class::get_error_code" ref="a0bb9bf8b7ec1295235cc9fb8a0809a34" args="(void *aux=0)" -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_error_code</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9bb71ee890cf1b9ec3644f9e0e5cf6b5">has_special_character</a> (char c, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状名に引数<em>c</em> で渡した特殊記号があるかどうか。  <a href="#a9bb71ee890cf1b9ec3644f9e0e5cf6b5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2110e22e2c2f4a9e0ee125c9b06497c5"></a><!-- doxytag: member="sxsdk::shape_class::set_diffuse_color" ref="a2110e22e2c2f4a9e0ee125c9b06497c5" args="(const sxsdk::rgb_class &amp;color, void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_diffuse_color</b> (const sxsdk::rgb_class &amp;color, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aef35a392a86b34e36952ce020a541630">link_object</a> (const sxsdk::mat4 &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リンク形状を作成する。  <a href="#aef35a392a86b34e36952ce020a541630"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__saver__interface.html">shape_saver_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aab3eefc8a1ef6a4c8e5037f3179d2f7f">create_shape_saver_interface</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">アンドゥ処理のために<code>create_shape_saver_interface</code> オブジェクトを生成する  <a href="#aab3eefc8a1ef6a4c8e5037f3179d2f7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1texture__interface.html">sxsdk::texture_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a375b028540d8b0e20f2d5135b3574d29">create_texture_interface</a> (int self=0, const sxsdk::vec3 &amp;point=sxsdk::vec3(0.0f, 0.0f, 0.0f), const sxsdk::vec3 &amp;shading_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;geometric_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;incident=sxsdk::vec3(0.0f, 0.0f,-1.0f), const sxsdk::vec2 *uv=0, const sxsdk::vec3 *du=0, const sxsdk::vec3 *dv=0, const sxsdk::vec4 *uvs=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">テクスチャ計算を行うためのtexture_interfaceを作成する。  <a href="#a375b028540d8b0e20f2d5135b3574d29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1aaf15f8701f85351d8d8a6cf36000b"></a><!-- doxytag: member="sxsdk::shape_class::get_radiosity_attributes_interface" ref="ac1aaf15f8701f85351d8d8a6cf36000b" args="(void *=0) const " -->
virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1radiosity__attributes__interface.html">sxsdk::radiosity_attributes_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ac1aaf15f8701f85351d8d8a6cf36000b">get_radiosity_attributes_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ラジオシティ属性を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a94cfcd5e44d85a9bea0acf40be30f95a"></a><!-- doxytag: member="sxsdk::shape_class::get_links" ref="a94cfcd5e44d85a9bea0acf40be30f95a" args="(part_class *list[], void *=0) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a94cfcd5e44d85a9bea0acf40be30f95a">get_links</a> (<a class="el" href="structsxsdk_1_1part__class.html">part_class</a> *list[], void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リンク先のパートオブジェクトを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#af8287e0ec7a3f5771d44ced0d8d84b28">move_links</a> (const sxsdk::mat4 &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リンク先の形状に影響を与えないようにリンク形状を移動する。  <a href="#af8287e0ec7a3f5771d44ced0d8d84b28"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae900e19f43b95b1cf3423d949c2633aa"></a><!-- doxytag: member="sxsdk::shape_class::get_linked_dad" ref="ae900e19f43b95b1cf3423d949c2633aa" args="(void *=0) const " -->
virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae900e19f43b95b1cf3423d949c2633aa">get_linked_dad</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リンクを考慮した親形状を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a989448eb168691aa7fde5646b99cb83c"></a><!-- doxytag: member="sxsdk::shape_class::get_exception_string" ref="a989448eb168691aa7fde5646b99cb83c" args="() const " -->
virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_exception_string</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a839cd1659a388ec1a1f14ad01d2dd63e"></a><!-- doxytag: member="sxsdk::shape_class::get_skin_deprecated" ref="a839cd1659a388ec1a1f14ad01d2dd63e" args="(int i, void *aux=0)" -->
virtual <a class="el" href="structsxsdk_1_1skin__class.html">skin_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_skin_deprecated</b> (int i, void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a764427a3e9d8e1a9d37568cf598cacf1"></a><!-- doxytag: member="sxsdk::shape_class::get_number_of_skin_points" ref="a764427a3e9d8e1a9d37568cf598cacf1" args="(void *=0) const " -->
virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a764427a3e9d8e1a9d37568cf598cacf1">get_number_of_skin_points</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スキン設定がされた頂点の数を取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae72d8aa677b7ea42713a83ef4440af9c">has_symbol</a> (char symbol, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状名に引数<em>c</em> で渡した特殊記号があるかどうか。  <a href="#ae72d8aa677b7ea42713a83ef4440af9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ab260b76a73175803efa58300bb8cb56e">is_container</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">階層下に形状を含むことができるかどうか。(パートかどうか)か判定する。  <a href="#ab260b76a73175803efa58300bb8cb56e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1control__point__class.html">sxsdk::control_point_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9c39b3abcad65b2f9b536f59a43a892e">control_point</a> (int i, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">引数iで指定されたコントロールポイントの参照を取得する。  <a href="#a9c39b3abcad65b2f9b536f59a43a892e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85aa6bd010fae4c66e8ad62458a15e13"></a><!-- doxytag: member="sxsdk::shape_class::is_rotator_joint" ref="a85aa6bd010fae4c66e8ad62458a15e13" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a85aa6bd010fae4c66e8ad62458a15e13">is_rotator_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2792ff3ba5b83c0730401f57fa7bd1dc"></a><!-- doxytag: member="sxsdk::shape_class::is_slider_joint" ref="a2792ff3ba5b83c0730401f57fa7bd1dc" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2792ff3ba5b83c0730401f57fa7bd1dc">is_slider_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">直線移動ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afce36bb0a81286c7819a6a86d54cd574"></a><!-- doxytag: member="sxsdk::shape_class::is_scale_joint" ref="afce36bb0a81286c7819a6a86d54cd574" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#afce36bb0a81286c7819a6a86d54cd574">is_scale_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">拡大縮小ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a385b49bb4ff2b427fd42bfaf0d16005f"></a><!-- doxytag: member="sxsdk::shape_class::is_uniscale_joint" ref="a385b49bb4ff2b427fd42bfaf0d16005f" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a385b49bb4ff2b427fd42bfaf0d16005f">is_uniscale_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">均等拡大縮小ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e1b3d5fb0c8070510e4c5007ed64c92"></a><!-- doxytag: member="sxsdk::shape_class::is_light_effector" ref="a5e1b3d5fb0c8070510e4c5007ed64c92" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5e1b3d5fb0c8070510e4c5007ed64c92">is_light_effector</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">光源ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad3caa269982ad931fb5a8097401f1642"></a><!-- doxytag: member="sxsdk::shape_class::is_path_joint" ref="ad3caa269982ad931fb5a8097401f1642" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad3caa269982ad931fb5a8097401f1642">is_path_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パスジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a24cb0c1234561af1e321d9748c5ffe74"></a><!-- doxytag: member="sxsdk::shape_class::is_morph_effector" ref="a24cb0c1234561af1e321d9748c5ffe74" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a24cb0c1234561af1e321d9748c5ffe74">is_morph_effector</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">変形ジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f69f44e1a8be7c9d18cbd992cd2b2c1"></a><!-- doxytag: member="sxsdk::shape_class::is_ball_joint" ref="a4f69f44e1a8be7c9d18cbd992cd2b2c1" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4f69f44e1a8be7c9d18cbd992cd2b2c1">is_ball_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ボールジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2897eddc1f7505a5b5e2cc80cd58d36f"></a><!-- doxytag: member="sxsdk::shape_class::is_custom_joint" ref="a2897eddc1f7505a5b5e2cc80cd58d36f" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2897eddc1f7505a5b5e2cc80cd58d36f">is_custom_joint</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">カスタムジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1rotator__joint__interface.html">sxsdk::rotator_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4ee3083613ad4e97d2726d2746878cfb">get_rotator_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">回転ジョイントを取得する。  <a href="#a4ee3083613ad4e97d2726d2746878cfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1slider__joint__interface.html">sxsdk::slider_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa76770fb2a400a7b1855814084bd24ac">get_slider_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">直線移動ジョイントを取得する。  <a href="#aa76770fb2a400a7b1855814084bd24ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1scale__joint__interface.html">sxsdk::scale_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7264f015119bd6c274415dc221adf164">get_scale_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">拡大縮小ジョイントを取得する。  <a href="#a7264f015119bd6c274415dc221adf164"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1uniscale__joint__interface.html">sxsdk::uniscale_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8ca83886895acd5efac10d6f75e700f2">get_uniscale_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">均等拡大縮小ジョイントを取得する。  <a href="#a8ca83886895acd5efac10d6f75e700f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1light__effector__interface.html">sxsdk::light_effector_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a64f7c8a27261d9fd54dc89b67eee93e7">get_light_effector_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">光源ジョイントを取得する。  <a href="#a64f7c8a27261d9fd54dc89b67eee93e7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1path__joint__interface.html">sxsdk::path_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a46ebf92c3c4dbd3af3e2f65fe2ba8375">get_path_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パスジョイントを取得する。  <a href="#a46ebf92c3c4dbd3af3e2f65fe2ba8375"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1morph__effector__interface.html">sxsdk::morph_effector_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a89d3139987ef5c5b1f9d02764ac0831d">get_morph_effector_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">変形ジョイントを取得する。  <a href="#a89d3139987ef5c5b1f9d02764ac0831d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1ball__joint__interface.html">sxsdk::ball_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a3641b9afa55fa2b2feee8e72254e2d1f">get_ball_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ボールジョイントを取得する。  <a href="#a3641b9afa55fa2b2feee8e72254e2d1f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1custom__joint__interface.html">sxsdk::custom_joint_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa152a15a733cc2dc2472986adcc71436">get_custom_joint_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">カスタムジョイントを取得する。  <a href="#aa152a15a733cc2dc2472986adcc71436"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ef83274db1f4bfca2288045a044f1f6"></a><!-- doxytag: member="sxsdk::shape_class::stream_to_clipboard" ref="a5ef83274db1f4bfca2288045a044f1f6" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5ef83274db1f4bfca2288045a044f1f6">stream_to_clipboard</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">オブジェクトの内容をテキスト（XML）としてクリップボードにコピーする。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1skin__class.html">skin_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a94a8c1504bf7a0361c6e14ace129b147">get_skin</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">頂点を持たない、または１つだけの形状のスキンを取得する。  <a href="#a94a8c1504bf7a0361c6e14ace129b147"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2cd98e4f6c47fad561e447a77765481e">get_nonnil_surface_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">表面材質を取得する。  <a href="#a2cd98e4f6c47fad561e447a77765481e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a312ba2011231d799a170aa14d92a55ae">inactivate</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状を選択解除する。  <a href="#a312ba2011231d799a170aa14d92a55ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a4b76c527c5fd568479fd57b3aaf513bb">create_attribute_stream_interface_with_uuid</a> (const sx::uuid_class &amp;stream_id, const sx::uuid_class &amp;wireframe_id=sxsdk::uuid_from_pluginid(0), const sx::uuid_class &amp;intersection_id=sxsdk::uuid_from_pluginid(0), const sx::uuid_class &amp;renderingobject_id=sxsdk::uuid_from_pluginid(0), void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">カスタム属性ストリームを生成する。形状にプラグイン独自の情報を付与できる。  <a href="#a4b76c527c5fd568479fd57b3aaf513bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae5e5dde1649c7935e18bd52e4bc81f22">get_attribute_stream_interface_with_uuid</a> (const sx::uuid_class &amp;stream_id, void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">属性ストリームを取得する。  <a href="#ae5e5dde1649c7935e18bd52e4bc81f22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1ef5725cb185bc43328806914b128902">delete_attribute_with_uuid</a> (const sx::uuid_class &amp;stream_id, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">カスタム属性を削除する。  <a href="#a1ef5725cb185bc43328806914b128902"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a7b2bf3bac1ac1fd16b30ad9dfbfe9864">get_proxy_shape</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">プロクシ形状を取得する。(const)  <a href="#a7b2bf3bac1ac1fd16b30ad9dfbfe9864"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0a472440060766e64740d230e64bc927">get_proxy_shape</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">プロクシ形状を取得する。  <a href="#a0a472440060766e64740d230e64bc927"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1surface__class.html">surface_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0ddbc11035d029929fafb16259df7a56">get_surface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">表面材質を取得する。  <a href="#a0ddbc11035d029929fafb16259df7a56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae2ad50ef25998543e114f31a7ceedc5b">get_parent</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">親の形状を取得する。  <a href="#ae2ad50ef25998543e114f31a7ceedc5b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6c298a3cf84eee4c0e7d7bc463847b0c">get_linked_parent</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">リンクを考慮した親形状を取得する。  <a href="#a6c298a3cf84eee4c0e7d7bc463847b0c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e64072d8af8d5b6b6b68709575b3e63"></a><!-- doxytag: member="sxsdk::shape_class::push_transformation_matrix" ref="a0e64072d8af8d5b6b6b68709575b3e63" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0e64072d8af8d5b6b6b68709575b3e63">push_transformation_matrix</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状の変換マトリクス値を（形状ごとの）スタックにプッシュする。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a96aae9752926542ed89da6fca757bd30"></a><!-- doxytag: member="sxsdk::shape_class::pop_transformation_matrix" ref="a96aae9752926542ed89da6fca757bd30" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a96aae9752926542ed89da6fca757bd30">pop_transformation_matrix</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">マトリクス値をスタックからポップして、形状の変換マトリクスに代入する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a01e78a6f1b15b9e0181c2e3bfa86d4bf">set_rendering</a> (int rendering_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">レンダリングの対象となるかどうかを設定する。  <a href="#a01e78a6f1b15b9e0181c2e3bfa86d4bf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a00b22b59264d309ea8198c7822782e01">get_rendering</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">レンダリングの対象となるかどうかを取得する。  <a href="#a00b22b59264d309ea8198c7822782e01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2cca4957fa8ca760cb99de053c54f3f5"></a><!-- doxytag: member="sxsdk::shape_class::convert_to_polygon_mesh_with_subdivision_level" ref="a2cca4957fa8ca760cb99de053c54f3f5" args="(int level, void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2cca4957fa8ca760cb99de053c54f3f5">convert_to_polygon_mesh_with_subdivision_level</a> (int level, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">分割レベルを指定して、形状をポリゴンメッシュに変換する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8e0ee9d9409395fc45c5dd704c222787">convert_to_polygon_mesh_with_divisions</a> (int lateral_division, int longitudinal_division, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">縦横の分割数を指定して、形状をポリゴンメッシュに変換する。  <a href="#a8e0ee9d9409395fc45c5dd704c222787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a85e549991335053e258ce47b8b821bb1">convert_to_polygon_mesh_with</a> (int level=-1, int lateral=-1, int longitudinal=-1, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">分割レベル、または縦横の分割数を指定して、形状をポリゴンメッシュに変換する。  <a href="#a85e549991335053e258ce47b8b821bb1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a8de1bdcb5a9462dee49ffd8122d6e0af">get_shadow_catcher</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウキャッチャーを取得する。  <a href="#a8de1bdcb5a9462dee49ffd8122d6e0af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a347530416943ef1ac855f0f87ac715c4">set_shadow_catcher</a> (int shadow_catcher_param, void *=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">シャドウキャッチャーを設定する。  <a href="#a347530416943ef1ac855f0f87ac715c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc381e2a28c365b76edab4aa930b3158"></a><!-- doxytag: member="sxsdk::shape_class::invalidate_vertex_array" ref="adc381e2a28c365b76edab4aa930b3158" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>invalidate_vertex_array</b> (void *aux=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51ea376dce1d3d20300e78ba76747934"></a><!-- doxytag: member="sxsdk::shape_class::get_sound_track_interface" ref="a51ea376dce1d3d20300e78ba76747934" args="(void *=0) const " -->
virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1sound__track__interface.html">sxsdk::sound_track_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a51ea376dce1d3d20300e78ba76747934">get_sound_track_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">サウンドトラックインターフェイスを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4a78750260df55613c020d54f77f397"></a><!-- doxytag: member="sxsdk::shape_class::is_sound_track" ref="af4a78750260df55613c020d54f77f397" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#af4a78750260df55613c020d54f77f397">is_sound_track</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">サウンドトラックか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1reverse__iterator.html">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a424a4503f253da136a3a4217ed7b3562">rbegin</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">逆方向のイテレータを返す。  <a href="#a424a4503f253da136a3a4217ed7b3562"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1reverse__iterator.html">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a981d9a8453cd5dc8a6d78bb7d980ce29">rend</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">逆方向のイテレータを返す。  <a href="#a981d9a8453cd5dc8a6d78bb7d980ce29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad013928d420167976bec808502b5a64b">get_master_image</a> (void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a></code> を取得する(<code>const</code> )。形状の種類がイメージオブジェクトではない場合は例外を投げる。  <a href="#ad013928d420167976bec808502b5a64b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a17133749fde8ae3e1b5a15149cc11a98">get_master_image</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a></code> を取得する。形状の種類がイメージオブジェクトではない場合は例外を投げる。  <a href="#a17133749fde8ae3e1b5a15149cc11a98"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96">set_related_shape</a> (const sx::uuid_class &amp;relation_id, <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *shape, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状と形状を相互に関連付けする。  <a href="#ab7ac881abe095d50160bb04d1479bd96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa1530d962009930861be2d9f40a01c3b">get_related_shapes</a> (const sx::uuid_class &amp;relation_id, <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> **shapes=0, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a></code> で関連付けされた形状のリストを取得する。  <a href="#aa1530d962009930861be2d9f40a01c3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a9173a534713e89cedfbfbc84684b7db4">delete_relation</a> (const sx::uuid_class &amp;relation_id, <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *shape=0, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a></code> で設定した関連付けを削除する。  <a href="#a9173a534713e89cedfbfbc84684b7db4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae89c7c293f5ce74677b4135af447f958"></a><!-- doxytag: member="sxsdk::shape_class::is_switch_effector" ref="ae89c7c293f5ce74677b4135af447f958" args="(void *=0) const " -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae89c7c293f5ce74677b4135af447f958">is_switch_effector</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スイッチジョイントか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <br class="typebreak"/>
<a class="el" href="structsxsdk_1_1switch__effector__interface.html">sxsdk::switch_effector_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ae4d7e9a14dc205ce3a9f279bfc071553">get_switch_effector_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スイッチジョイントを取得する。  <a href="#ae4d7e9a14dc205ce3a9f279bfc071553"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a731c9186f7b7e38f136264319b1a3fbe"></a><!-- doxytag: member="sxsdk::shape_class::get_implementation" ref="a731c9186f7b7e38f136264319b1a3fbe" args="(void *=0) const " -->
virtual test <br class="typebreak"/>
implementation_interface &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_implementation</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aabeeca6133d3f0d7487f40ed75f6db3e">get_tag_intValue</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして形状に登録されている値を取得する  <a href="#aabeeca6133d3f0d7487f40ed75f6db3e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a472aa41278311f7f77fced2c6ec522f2">get_tag_doubleValue</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして形状に登録されている値を取得する  <a href="#a472aa41278311f7f77fced2c6ec522f2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6bba70e96cdf72a492885a9dcac88491">get_tag_floatValue</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして形状に登録されている値を取得する  <a href="#a6bba70e96cdf72a492885a9dcac88491"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad7d223f378bca53e76e8fcbe848fa707">get_tag_stringValue</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして形状に登録されている値を取得する  <a href="#ad7d223f378bca53e76e8fcbe848fa707"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a04b07ddaaf0966ee1af9215313dc8c20">get_tag_boolValue</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして形状に登録されている値を取得する  <a href="#a04b07ddaaf0966ee1af9215313dc8c20"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a5bbca8931055f404c497ef63de28bc1d">set_tag_intValue</a> (const char *tagName, int value, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして値を形状にセットする  <a href="#a5bbca8931055f404c497ef63de28bc1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a0d980750ce02d382aed43aa375cffbb9">set_tag_doubleValue</a> (const char *tagName, double value, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして値を形状にセットする  <a href="#a0d980750ce02d382aed43aa375cffbb9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ad7acdc7fe6e5744c1c4059ccd590a661">set_tag_floatValue</a> (const char *tagName, float value, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして値を形状にセットする  <a href="#ad7acdc7fe6e5744c1c4059ccd590a661"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1c13dc28bd9519d90812e7602f82f0cf">set_tag_stringValue</a> (const char *tagName, const char *value, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして値を形状にセットする  <a href="#a1c13dc28bd9519d90812e7602f82f0cf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1ab4b5d0b80a698701133c3259bd843f">set_tag_boolValue</a> (const char *tagName, bool value, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとして値を形状にセットする  <a href="#a1ab4b5d0b80a698701133c3259bd843f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#ab9b43c1d541848773875dd86d1d525c6">tag_value_type</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">tag名称をキーとしてセットした値を種類を取得する  <a href="#ab9b43c1d541848773875dd86d1d525c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2643acb5817d07f17f3dcfcb651804f9"></a><!-- doxytag: member="sxsdk::shape_class::tags" ref="a2643acb5817d07f17f3dcfcb651804f9" args="(void *aux=0)" -->
std::vector&lt; const char * &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a2643acb5817d07f17f3dcfcb651804f9">tags</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状に設定されたtag名称一覧 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a09f473ff12a67ac5e72dc74be795d124">has_tag</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">指定されたtag名称が形状に設定されているか  <a href="#a09f473ff12a67ac5e72dc74be795d124"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a34dbdf209bedd00db32f8d5ee305e6a7">remove_tag</a> (const char *tagName, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状に設定されたtagを削除する  <a href="#a34dbdf209bedd00db32f8d5ee305e6a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77462f0c8c8e1a07d0559da2210f7ba6"></a><!-- doxytag: member="sxsdk::shape_class::get_uuid" ref="a77462f0c8c8e1a07d0559da2210f7ba6" args="(void *=0) const " -->
sx::uuid_class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a77462f0c8c8e1a07d0559da2210f7ba6">get_uuid</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">形状のUUIDを取得するを取得する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">polygon_mesh_interface *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a1ba195f4c2f237efac5865b539f503f7">create_converted_polygon_mesh_interface</a> (int level, int texture, bool triangulate, bool divide, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ポリゴンメッシュに変換したテンポラリ形状を生成する。  <a href="#a1ba195f4c2f237efac5865b539f503f7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#adf03b9397a5a3855065822aa6bc0e8cb">get_sequence_transformation</a> (float sequence_value, void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>frame</em> で渡したシーケンス値における、形状の変換マトリクスを返す。  <a href="#adf03b9397a5a3855065822aa6bc0e8cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a02d6a95c0fccde11cf1e2829f698e977">get_sequence_joint_matrix</a> (float sequence_value, void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>frame</em> で渡したシーケンス値における、ジョイント変換マトリクス  <a href="#a02d6a95c0fccde11cf1e2829f698e977"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a10725787b79d2d412881b04d5f9239fd">create_converted_polyline_points_interface</a> (int level=2, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">開いた線形状、円をポリラインに変換した<code>points_interfaceを生成する。</code>  <a href="#a10725787b79d2d412881b04d5f9239fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a28a6e67fd2b4f903ffee23f816514c13">get_sequence_local_to_world_matrix</a> (float sequence_value, void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>frame</em> で渡したシーケンス値における、ローカル座標系からワールド座標系への変換マトリクス  <a href="#a28a6e67fd2b4f903ffee23f816514c13"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">sxsdk::mat4&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aeb478d99129a1b3be42bdd7e488dd0b1">get_sequence_world_to_local_matrix</a> (float sequence_value, void *aux=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><em>frame</em> で渡したシーケンス値における、ワールド座標系からローカル座標系への変換マトリクス  <a href="#aeb478d99129a1b3be42bdd7e488dd0b1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6e6c3edc8837fd5d71293ab589caca62"></a><!-- doxytag: member="sxsdk::shape_class::is_path_replicator" ref="a6e6c3edc8837fd5d71293ab589caca62" args="(void *=0) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a6e6c3edc8837fd5d71293ab589caca62">is_path_replicator</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パスリプリケータか判定する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxsdk_1_1path__replicator__interface.html">sxsdk::path_replicator_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aad3779fc59e01104051cf980d11357bc">get_path_replicator_interface</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">パスリプリケータを取得する。  <a href="#aad3779fc59e01104051cf980d11357bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250d47d73632e8a54cb933e8f142572d"></a><!-- doxytag: member="sxsdk::shape_class::set_bounding_box_size" ref="a250d47d73632e8a54cb933e8f142572d" args="(sxsdk::vec3 bounding_box_size_param, void *=0)" -->
testshape_class &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_bounding_box_size</b> (sxsdk::vec3 bounding_box_size_param, void *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a194b0f6065838090e5dac649e14fdebe"></a><!-- doxytag: member="sxsdk::shape_class::get_bounding_box_size" ref="a194b0f6065838090e5dac649e14fdebe" args="(void *=0) const " -->
testsxsdk::vec3&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_bounding_box_size</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxsdk_1_1surface__class.html">surface_class</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#abff3583d7c8ec5f97cfd1faeb79a6adc">get_surface_reference</a> (void *=0) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">表面材質を取得する。  <a href="#abff3583d7c8ec5f97cfd1faeb79a6adc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8595c573771d3640acac8406a309086c"></a><!-- doxytag: member="sxsdk::shape_class::set_bounding_box_center" ref="a8595c573771d3640acac8406a309086c" args="(sxsdk::vec3 bounding_box_center_param, void *=0)" -->
testshape_class &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_bounding_box_center</b> (sxsdk::vec3 bounding_box_center_param, void *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad4970d40944b8b25fd19081e7883511a"></a><!-- doxytag: member="sxsdk::shape_class::get_bounding_box_center" ref="ad4970d40944b8b25fd19081e7883511a" args="(void *=0) const " -->
testsxsdk::vec3&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_bounding_box_center</b> (void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac9da7ca8a163ecbd092d272404cc4225"></a><!-- doxytag: member="sxsdk::shape_class::set_active_vertex_indices" ref="ac9da7ca8a163ecbd092d272404cc4225" args="(int n, int list[], void *=0)" -->
testshape_class &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>set_active_vertex_indices</b> (int n, int list[], void *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1067d91995ade3dcf55033bd8a0244ed"></a><!-- doxytag: member="sxsdk::shape_class::get_active_vertex_indices" ref="a1067d91995ade3dcf55033bd8a0244ed" args="(int list[], void *=0) const " -->
testint&nbsp;</td><td class="memItemRight" valign="bottom"><b>get_active_vertex_indices</b> (int list[], void *=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4ddb4d7ec36388aa5b1f910e004dc72"></a><!-- doxytag: member="sxsdk::shape_class::update_skin_bindings" ref="aa4ddb4d7ec36388aa5b1f910e004dc72" args="()" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#aa4ddb4d7ec36388aa5b1f910e004dc72">update_skin_bindings</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">スキンのバインド状態を更新する。 <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsxsdk_1_1texture__interface.html">sxsdk::texture_interface</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1shape__class.html#a3762c40560071819f1c25f67568344a3">create_texture_interface2</a> (int self=0, const sxsdk::vec3 &amp;point=sxsdk::vec3(0.0f, 0.0f, 0.0f), const sxsdk::vec3 &amp;shading_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;geometric_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;incident=sxsdk::vec3(0.0f, 0.0f,-1.0f), const sxsdk::vec2 *uv=0, const sxsdk::vec3 *du=0, const sxsdk::vec3 *dv=0, int n_uvs=0, const sxsdk::vec2 *uvs=0, sxsdk::master_surface_class *master_surface=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">テクスチャ計算を行うためのtexture_interfaceを作成する。複数UVを扱う場合はcreate_texture_interface2を使用。  <a href="#a3762c40560071819f1c25f67568344a3"></a><br/></td></tr>
</table>
<hr/><h2>関数</h2>
<a class="anchor" id="a5a63ae8f64099f5f8f4c9eedbbffae3e"></a><!-- doxytag: member="sxsdk::shape_class::append_skin" ref="a5a63ae8f64099f5f8f4c9eedbbffae3e" args="(part_class &amp;part, float weight=1.0, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::append_skin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1part__class.html">part_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>weight</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スキン設定を追加する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>part</em>&nbsp;</td><td>適用するジョイント </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>weight</em>&nbsp;</td><td>適用率 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40fb84dcfb17b83ca6b1ddb521de0737"></a><!-- doxytag: member="sxsdk::shape_class::begin" ref="a40fb84dcfb17b83ca6b1ddb521de0737" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1iterator.html">iterator</a> sxsdk::shape_class::begin </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>下位階層の最初の形状のイテレータを取得する。 </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// 選択形状以下のすべての形状の名前をデフォルト名にする </span>
 <span class="keywordtype">void</span> reset_shape_name (<a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape) { 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a7afcd59713aa04be787b73667aed96b2" title="形状の名前を設定する。">set_name</a>(0); 
     <span class="keywordflow">for</span>(<a class="code" href="classsxsdk_1_1shape__class_1_1iterator.html">sxsdk::shape_class::iterator</a> i = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a40fb84dcfb17b83ca6b1ddb521de0737" title="下位階層の最初の形状のイテレータを取得する。">begin</a>() ; i != shape.<a class="code" href="structsxsdk_1_1shape__class.html#a7a5b031257e482c32cb306a47244bc6d" title="下位階層の最後の形状(番兵形状)のイテレータを取得する。">end</a>() ; ++i) { 
         reset_shape_name(*i); 
     } 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a3c3da530b8f065de1388404d4e292188"></a><!-- doxytag: member="sxsdk::shape_class::begin_set_point" ref="a3c3da530b8f065de1388404d4e292188" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::begin_set_point </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ワイヤーフレームの更新を一時的に停止する。 </p>
<p>同じ形状に対して連続してポイントの編集をする場合に、<code><a class="el" href="structsxsdk_1_1shape__class.html#a3c3da530b8f065de1388404d4e292188" title="ワイヤーフレームの更新を一時的に停止する。">begin_set_point()</a></code> と<code><a class="el" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493" title="ワイヤーフレームの更新を再開する。">end_set_point()</a></code> で囲むと、個々の操作結果はワイヤーフレーム表示に反映されなくなる。その結果、ポイントの編集が高速に行える。</p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493" title="ワイヤーフレームの更新を再開する。">end_set_point()</a></code> によって通常にワイヤーフレームが更新される状態に戻る。</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape = scene-&gt;active_shape(); 
 <span class="keywordflow">if</span>(shape.<a class="code" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type</a>() == <a class="code" href="namespacesxsdk_1_1enums.html#aa6cc70b74636bfbf63bbfb8a2da2ce52a6cf73eac58cb306f11b486d008bf1469" title="線形状">enums::line</a>) { 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a3c3da530b8f065de1388404d4e292188" title="ワイヤーフレームの更新を一時的に停止する。">begin_set_point</a>(); 
     <span class="keyword">const</span> sxsdk::mat4 local_to_world_matrix = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a8f6c4c8a6e1a288c3a932bb8b9828784" title="ローカル座標系からワールド座標系への変換マトリクスを取得する。...">get_local_to_world_matrix</a>(); 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0 ; i &lt; shape.<a class="code" href="structsxsdk_1_1shape__class.html#a63db5b00d013ef2a50482f723488bbf9" title="コントロールポイントの総数を取得する。">get_total_number_of_control_points</a>() ; ++i) { 
         control_point_class&amp; p = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a9c39b3abcad65b2f9b536f59a43a892e" title="引数iで指定されたコントロールポイントの参照を取得する。...">control_point</a>(i); 
         p.<a class="code" href="structsxsdk_1_1control__point__class.html#a0cadb52e4b4ff2c3b937fedbba318a29" title="アンカーポイントの位置を設定する。">set_position</a>(p.get_potision() * local_to_world_matrix); 
     } 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493" title="ワイヤーフレームの更新を再開する。">end_set_point</a>(); 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a9c39b3abcad65b2f9b536f59a43a892e"></a><!-- doxytag: member="sxsdk::shape_class::control_point" ref="a9c39b3abcad65b2f9b536f59a43a892e" args="(int i, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1control__point__class.html">sxsdk::control_point_class</a>&amp; sxsdk::shape_class::control_point </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>引数iで指定されたコントロールポイントの参照を取得する。 </p>
<p>コントロールポイントの数は<code><a class="el" href="structsxsdk_1_1shape__class.html#a63db5b00d013ef2a50482f723488bbf9" title="コントロールポイントの総数を取得する。">get_total_number_of_control_points()</a></code> で取得する。</p>
<p>ポリゴンメッシュなど、コントロールポイントを持たない形状では例外を投げる。(ポリゴンメッシュの頂点は<code><a class="el" href="structsxsdk_1_1polygon__mesh__class.html#ab232f9e186c1f1cc07577df8d919dd13" title="指定された頂点の参照を返す。">polygon_mesh_class::vertex()</a></code> を使用する)</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>コントロールポイントの番号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85e549991335053e258ce47b8b821bb1"></a><!-- doxytag: member="sxsdk::shape_class::convert_to_polygon_mesh_with" ref="a85e549991335053e258ce47b8b821bb1" args="(int level=&#45;1, int lateral=&#45;1, int longitudinal=&#45;1, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::convert_to_polygon_mesh_with </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lateral</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>longitudinal</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>分割レベル、または縦横の分割数を指定して、形状をポリゴンメッシュに変換する。 </p>
<p>levelがゼロまたは正の場合には、その分割レベルで分割する。levelが-1で、lateralとlongitudinalが正の場合には、指定された分割数で分割する。</p>
<p>通常パートなど、形状の種類によっては、縦横の分割数の指定が意味をなさないこともある。その場合には、縦横の分割数を指定しても実際にはデフォルト（通常）の分割レベルで分割する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>分割レベル。0:分割しない（または最低限の分割）、1:荒い分割、2:普通の分割、3:細かい分割.... </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lateral</em>&nbsp;</td><td>横方向の分割数 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>longitudinal</em>&nbsp;</td><td>縦方向の分割数 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e0ee9d9409395fc45c5dd704c222787"></a><!-- doxytag: member="sxsdk::shape_class::convert_to_polygon_mesh_with_divisions" ref="a8e0ee9d9409395fc45c5dd704c222787" args="(int lateral_division, int longitudinal_division, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::convert_to_polygon_mesh_with_divisions </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lateral_division</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>longitudinal_division</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>縦横の分割数を指定して、形状をポリゴンメッシュに変換する。 </p>
<p>通常パートなど、形状の種類によっては、縦横の分割数の指定が意味をなさないこともある。その場合には、デフォルト（通常）の分割レベルで分割する。 </p>

</div>
</div>
<a class="anchor" id="a9bad0cd487e7a691dfd16f962b9d571d"></a><!-- doxytag: member="sxsdk::shape_class::copy_object" ref="a9bad0cd487e7a691dfd16f962b9d571d" args="(const sxsdk::mat4 &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; sxsdk::shape_class::copy_object </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を複製する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>形状複製のための変換マトリクス </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b76c527c5fd568479fd57b3aaf513bb"></a><!-- doxytag: member="sxsdk::shape_class::create_attribute_stream_interface_with_uuid" ref="a4b76c527c5fd568479fd57b3aaf513bb" args="(const sx::uuid_class &amp;stream_id, const sx::uuid_class &amp;wireframe_id=sxsdk::uuid_from_pluginid(0), const sx::uuid_class &amp;intersection_id=sxsdk::uuid_from_pluginid(0), const sx::uuid_class &amp;renderingobject_id=sxsdk::uuid_from_pluginid(0), void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a>* sxsdk::shape_class::create_attribute_stream_interface_with_uuid </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>stream_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>wireframe_id</em> = <code>sxsdk::uuid_from_pluginid(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>intersection_id</em> = <code>sxsdk::uuid_from_pluginid(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>renderingobject_id</em> = <code>sxsdk::uuid_from_pluginid(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>カスタム属性ストリームを生成する。形状にプラグイン独自の情報を付与できる。 </p>
<p>作成した属性ストリームの取得は<code><a class="el" href="structsxsdk_1_1shape__class.html#ae5e5dde1649c7935e18bd52e4bc81f22" title="属性ストリームを取得する。">get_attribute_stream_interface_with_uuid()</a></code>, 削除は<code><a class="el" href="structsxsdk_1_1shape__class.html#a1ef5725cb185bc43328806914b128902" title="カスタム属性を削除する。">delete_attribute_with_uuid()</a></code> で行う。</p>
<p><em>wireframe_id</em> や<em>intersection_id</em> を指定することでワイヤフレームのカスタム描画、交点計算のカスタムを行うことができる。</p>
<p>すでに同じIDの属性ストリームを持っている場合には内容がクリアされる。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream_id</em>&nbsp;</td><td>属性ストリームの<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wireframe_id</em>&nbsp;</td><td><code><a class="el" href="structsxsdk_1_1attribute__interface.html">attribute_interface</a></code>, <code><a class="el" href="structsxsdk_1_1creator__interface.html">creator_interface</a></code>, <code><a class="el" href="structsxsdk_1_1modifier__interface.html">modifier_interface</a></code> から派生したクラスのプラグインIDを渡すと、各クラスの <code>make_wireframe()</code> によるワイヤフレームのカスタム描画が行える。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>intersection_id</em>&nbsp;</td><td><code><a class="el" href="structsxsdk_1_1attribute__interface.html">attribute_interface</a></code> から派生したクラスのプラグインIDを渡すと、<code><a class="el" href="structsxsdk_1_1attribute__interface.html#a365648974dc3236a763d321fbcaecc81" title="オーバライド可。交点計算を行う。(参照：メモリ常駐型プラグイン)...">attribute_interface::ray_intersection()</a></code> による交点計算のカスタムが行える。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>renderingobject_id</em>&nbsp;</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf8cec2c65adb28e0e9f52b4b1671a32"></a><!-- doxytag: member="sxsdk::shape_class::create_converted_meshes_interface" ref="aaf8cec2c65adb28e0e9f52b4b1671a32" args="(int level=2, int texture=0, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1meshes__interface.html">meshes_interface</a>* sxsdk::shape_class::create_converted_meshes_interface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>texture</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>メッシュに変換したテンポラリ形状を生成する。 </p>
<p>生成された<code><a class="el" href="structsxsdk_1_1meshes__interface.html">meshes_interface</a></code> はシーンに配置されず、オブジェクトの破棄と共に削除される。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>分割レベル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>テクスチャ解像度 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ba195f4c2f237efac5865b539f503f7"></a><!-- doxytag: member="sxsdk::shape_class::create_converted_polygon_mesh_interface" ref="a1ba195f4c2f237efac5865b539f503f7" args="(int level, int texture, bool triangulate, bool divide, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">polygon_mesh_interface* sxsdk::shape_class::create_converted_polygon_mesh_interface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>triangulate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>divide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ポリゴンメッシュに変換したテンポラリ形状を生成する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>分割レベル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>テクスチャ解像度 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>triangulate</em>&nbsp;</td><td>三角分割 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>divide</em>&nbsp;</td><td>divide </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c070f8e8f26b3de7b3f6b9f5b219b90"></a><!-- doxytag: member="sxsdk::shape_class::create_converted_polygon_mesh_interface" ref="a0c070f8e8f26b3de7b3f6b9f5b219b90" args="(int level=2, int texture=0, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual polygon_mesh_interface* sxsdk::shape_class::create_converted_polygon_mesh_interface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>texture</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ポリゴンメッシュに変換したテンポラリ形状を生成する。 </p>
<p>生成された<code>polygon_mesh_interface</code> はシーンに配置されず、オブジェクトの破棄と共に削除される。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>分割レベル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>texture</em>&nbsp;</td><td>テクスチャ解像度 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10725787b79d2d412881b04d5f9239fd"></a><!-- doxytag: member="sxsdk::shape_class::create_converted_polyline_points_interface" ref="a10725787b79d2d412881b04d5f9239fd" args="(int level=2, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a>* sxsdk::shape_class::create_converted_polyline_points_interface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>開いた線形状、円をポリラインに変換した<code>points_interfaceを生成する。</code> </p>
<p>生成された<code><a class="el" href="structsxsdk_1_1points__interface.html">points_interface</a></code> はシーンに配置されず、オブジェクトの破棄と共に削除される。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>分割レベル </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab3eefc8a1ef6a4c8e5037f3179d2f7f"></a><!-- doxytag: member="sxsdk::shape_class::create_shape_saver_interface" ref="aab3eefc8a1ef6a4c8e5037f3179d2f7f" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__saver__interface.html">shape_saver_interface</a>* sxsdk::shape_class::create_shape_saver_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>アンドゥ処理のために<code>create_shape_saver_interface</code> オブジェクトを生成する </p>
<p>詳しくは、<code><a class="el" href="structsxsdk_1_1shape__saver__interface.html">shape_saver_interface</a></code> を参照 </p>

<p><a class="el" href="structsxsdk_1_1part__class.html#af6433a5ad1ef521e90f3cc4703fdd185">sxsdk::part_class</a>, <a class="el" href="structsxsdk_1_1light__class.html#a45b678893e88674abccf26ec0c6b3e1c">sxsdk::light_class</a>, <a class="el" href="structsxsdk_1_1line__class.html#acf2458efb422f66362453682eb4c415a">sxsdk::line_class</a>, <a class="el" href="structsxsdk_1_1polygon__mesh__class.html#a7114090931f746561a0af21dd30547bf">sxsdk::polygon_mesh_class</a>, <a class="el" href="structsxsdk_1_1sphere__class.html#a675c6e69488ea5a597999370c71fe50a">sxsdk::sphere_class</a>, と <a class="el" href="structsxsdk_1_1disk__class.html#ac20dd3bf369bd113e4fe81146702ada0">sxsdk::disk_class</a>で再定義されています。</p>

</div>
</div>
<a class="anchor" id="a375b028540d8b0e20f2d5135b3574d29"></a><!-- doxytag: member="sxsdk::shape_class::create_texture_interface" ref="a375b028540d8b0e20f2d5135b3574d29" args="(int self=0, const sxsdk::vec3 &amp;point=sxsdk::vec3(0.0f, 0.0f, 0.0f), const sxsdk::vec3 &amp;shading_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;geometric_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;incident=sxsdk::vec3(0.0f, 0.0f,&#45;1.0f), const sxsdk::vec2 *uv=0, const sxsdk::vec3 *du=0, const sxsdk::vec3 *dv=0, const sxsdk::vec4 *uvs=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1texture__interface.html">sxsdk::texture_interface</a>* sxsdk::shape_class::create_texture_interface </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>self</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em> = <code>sxsdk::vec3(0.0f,&nbsp;0.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>shading_normal</em> = <code>sxsdk::vec3(0.0f,&nbsp;1.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>geometric_normal</em> = <code>sxsdk::vec3(0.0f,&nbsp;1.0f,&nbsp;0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>incident</em> = <code>sxsdk::vec3(0.0f,&nbsp;0.0f,-1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec2 *&nbsp;</td>
          <td class="paramname"> <em>uv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>du</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>dv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec4 *&nbsp;</td>
          <td class="paramname"> <em>uvs</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>テクスチャ計算を行うためのtexture_interfaceを作成する。 </p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>テクスチャのインデックス </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>テクスチャ座標 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shading_normal</em>&nbsp;</td><td>シェーディング上の法線。バンプマッピングなどにより変化 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometric_normal</em>&nbsp;</td><td>形状上の実際の法線 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incident</em>&nbsp;</td><td>入射ベクトル。視点からシェーディング点へのベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>UV値を設定(パラメータUV、距離UV共通)。<em>uvs</em> にUV値を指定した場合は無視される。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>du</em>&nbsp;</td><td>U方向の偏微分値を設定 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>V方向の偏微分値を設定 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvs</em>&nbsp;</td><td>パラメータUV値と距離UV値の配列。<code>sxsdk::vec4</code> の4つのデータの内、1, 2番目の値はパラメータの、3, 4番目の値は距離のUV値となる。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3762c40560071819f1c25f67568344a3"></a><!-- doxytag: member="sxsdk::shape_class::create_texture_interface2" ref="a3762c40560071819f1c25f67568344a3" args="(int self=0, const sxsdk::vec3 &amp;point=sxsdk::vec3(0.0f, 0.0f, 0.0f), const sxsdk::vec3 &amp;shading_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;geometric_normal=sxsdk::vec3(0.0f, 1.0f, 0.0f), const sxsdk::vec3 &amp;incident=sxsdk::vec3(0.0f, 0.0f,&#45;1.0f), const sxsdk::vec2 *uv=0, const sxsdk::vec3 *du=0, const sxsdk::vec3 *dv=0, int n_uvs=0, const sxsdk::vec2 *uvs=0, sxsdk::master_surface_class *master_surface=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxsdk_1_1texture__interface.html">sxsdk::texture_interface</a>* sxsdk::shape_class::create_texture_interface2 </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>self</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em> = <code>sxsdk::vec3(0.0f,0.0f,0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>shading_normal</em> = <code>sxsdk::vec3(0.0f,1.0f,0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>geometric_normal</em> = <code>sxsdk::vec3(0.0f,1.0f,0.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>incident</em> = <code>sxsdk::vec3(0.0f,0.0f,-1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec2 *&nbsp;</td>
          <td class="paramname"> <em>uv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>du</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>dv</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_uvs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec2 *&nbsp;</td>
          <td class="paramname"> <em>uvs</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1master__surface__class.html">sxsdk::master_surface_class</a> *&nbsp;</td>
          <td class="paramname"> <em>master_surface</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>テクスチャ計算を行うためのtexture_interfaceを作成する。複数UVを扱う場合はcreate_texture_interface2を使用。 </p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>self</em>&nbsp;</td><td>テクスチャのインデックス </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>point</em>&nbsp;</td><td>テクスチャ座標 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shading_normal</em>&nbsp;</td><td>シェーディング上の法線。バンプマッピングなどにより変化 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometric_normal</em>&nbsp;</td><td>形状上の実際の法線 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>incident</em>&nbsp;</td><td>入射ベクトル。視点からシェーディング点へのベクトル </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uv</em>&nbsp;</td><td>UV値を設定(パラメータUV、距離UV共通)。<em>uvs</em> にUV値を指定した場合は無視される。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>du</em>&nbsp;</td><td>U方向の偏微分値を設定 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dv</em>&nbsp;</td><td>V方向の偏微分値を設定 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n_uvs</em>&nbsp;</td><td>uvsの要素数。0-7まで指定できる。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvs</em>&nbsp;</td><td>UV値の配列。<code>複数UVを最大8層分格納できる。0番目は距離補正UV、1番目はパラメータUVに相当。</code> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>master_surface</em>&nbsp;</td><td>フェイスグループ使用時に割り当てられているmaster_surface_classのポインタ。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ef5725cb185bc43328806914b128902"></a><!-- doxytag: member="sxsdk::shape_class::delete_attribute_with_uuid" ref="a1ef5725cb185bc43328806914b128902" args="(const sx::uuid_class &amp;stream_id, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::delete_attribute_with_uuid </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>stream_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>カスタム属性を削除する。 </p>
<p>属性ストリームの作成は<code><a class="el" href="structsxsdk_1_1shape__class.html#a4b76c527c5fd568479fd57b3aaf513bb" title="カスタム属性ストリームを生成する。形状にプラグイン独自の情...">create_attribute_stream_interface_with_uuid()</a></code>, 取得は<code><a class="el" href="structsxsdk_1_1shape__class.html#ae5e5dde1649c7935e18bd52e4bc81f22" title="属性ストリームを取得する。">get_attribute_stream_interface_with_uuid()</a></code> で行う。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream_id</em>&nbsp;</td><td>属性ストリームの<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9173a534713e89cedfbfbc84684b7db4"></a><!-- doxytag: member="sxsdk::shape_class::delete_relation" ref="a9173a534713e89cedfbfbc84684b7db4" args="(const sx::uuid_class &amp;relation_id, sxsdk::shape_class *shape=0, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::delete_relation </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>relation_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td>
          <td class="paramname"> <em>shape</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a></code> で設定した関連付けを削除する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a>を呼び出した形状と、その引数に渡した形状のどちらからでも削除できる。</code> </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relation_id</em>&nbsp;</td><td>関連付けの種類を識別する<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shape</em>&nbsp;</td><td>関連付けがされている形状。0を渡すと、<em>relation_id</em> で設定されているすべての関連付けを削除する。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a5b031257e482c32cb306a47244bc6d"></a><!-- doxytag: member="sxsdk::shape_class::end" ref="a7a5b031257e482c32cb306a47244bc6d" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1iterator.html">iterator</a> sxsdk::shape_class::end </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>下位階層の最後の形状(番兵形状)のイテレータを取得する。 </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// 選択形状以下のすべての形状の名前をデフォルト名にする </span>
 <span class="keywordtype">void</span> reset_shape_name (<a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape) { 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a7afcd59713aa04be787b73667aed96b2" title="形状の名前を設定する。">set_name</a>(0); 
     <span class="keywordflow">for</span>(<a class="code" href="classsxsdk_1_1shape__class_1_1iterator.html">sxsdk::shape_class::iterator</a> i = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a40fb84dcfb17b83ca6b1ddb521de0737" title="下位階層の最初の形状のイテレータを取得する。">begin</a>() ; i != shape.<a class="code" href="structsxsdk_1_1shape__class.html#a7a5b031257e482c32cb306a47244bc6d" title="下位階層の最後の形状(番兵形状)のイテレータを取得する。">end</a>() ; ++i) { 
         reset_shape_name(*i); 
     } 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a2e019b101dff70fefbb66f679865a493"></a><!-- doxytag: member="sxsdk::shape_class::end_set_point" ref="a2e019b101dff70fefbb66f679865a493" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::end_set_point </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ワイヤーフレームの更新を再開する。 </p>
<p>同じ形状に対して連続してポイントの編集をする場合に、<code><a class="el" href="structsxsdk_1_1shape__class.html#a3c3da530b8f065de1388404d4e292188" title="ワイヤーフレームの更新を一時的に停止する。">begin_set_point()</a></code> と<code><a class="el" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493" title="ワイヤーフレームの更新を再開する。">end_set_point()</a></code> で囲むと、個々の操作結果はワイヤーフレーム表示に反映されなくなる。その結果、ポイントの編集が高速に行える。</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape = scene-&gt;active_shape(); 
 <span class="keywordflow">if</span>(shape.<a class="code" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type</a>() == <a class="code" href="namespacesxsdk_1_1enums.html#aa6cc70b74636bfbf63bbfb8a2da2ce52a6cf73eac58cb306f11b486d008bf1469" title="線形状">enums::line</a>) { 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a3c3da530b8f065de1388404d4e292188" title="ワイヤーフレームの更新を一時的に停止する。">begin_set_point</a>(); 
     <span class="keyword">const</span> sxsdk::mat4 local_to_world_matrix = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a8f6c4c8a6e1a288c3a932bb8b9828784" title="ローカル座標系からワールド座標系への変換マトリクスを取得する。...">get_local_to_world_matrix</a>(); 
     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0 ; i &lt; shape.<a class="code" href="structsxsdk_1_1shape__class.html#a63db5b00d013ef2a50482f723488bbf9" title="コントロールポイントの総数を取得する。">get_total_number_of_control_points</a>() ; ++i) { 
         control_point_class&amp; p = shape.<a class="code" href="structsxsdk_1_1shape__class.html#a9c39b3abcad65b2f9b536f59a43a892e" title="引数iで指定されたコントロールポイントの参照を取得する。...">control_point</a>(i); 
         p.<a class="code" href="structsxsdk_1_1control__point__class.html#a0cadb52e4b4ff2c3b937fedbba318a29" title="アンカーポイントの位置を設定する。">set_position</a>(p.get_potision() * local_to_world_matrix); 
     } 
     shape.<a class="code" href="structsxsdk_1_1shape__class.html#a2e019b101dff70fefbb66f679865a493" title="ワイヤーフレームの更新を再開する。">end_set_point</a>(); 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a0c43f1db671eab28283519aa41262dfe"></a><!-- doxytag: member="sxsdk::shape_class::get_active_control_point" ref="a0c43f1db671eab28283519aa41262dfe" args="(int at, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::get_active_control_point </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定したコントロールポイントの選択状態を取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a15be5f50617d9ba38272fb1cd35d1e5f" title="指定したコントロールポイントの選択状態を設定する。">set_active_control_point()</a></code> で選択状態を設定できる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>at</em>&nbsp;</td><td>コントロールポイントの番号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc1089a61be1db5de27c0ba324c53279"></a><!-- doxytag: member="sxsdk::shape_class::get_active_control_points" ref="adc1089a61be1db5de27c0ba324c53279" args="(int *p, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_active_control_points </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>選択されているコントロールポイントの番号のリストを取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a15be5f50617d9ba38272fb1cd35d1e5f" title="指定したコントロールポイントの選択状態を設定する。">set_active_control_point()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a0c43f1db671eab28283519aa41262dfe" title="指定したコントロールポイントの選択状態を取得する。">get_active_control_point()</a></code> でポイントごとの選択状態を設定、取得ができる。 </p>

</div>
</div>
<a class="anchor" id="ae5e5dde1649c7935e18bd52e4bc81f22"></a><!-- doxytag: member="sxsdk::shape_class::get_attribute_stream_interface_with_uuid" ref="ae5e5dde1649c7935e18bd52e4bc81f22" args="(const sx::uuid_class &amp;stream_id, void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1stream__interface.html">sxsdk::stream_interface</a>* sxsdk::shape_class::get_attribute_stream_interface_with_uuid </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>stream_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>属性ストリームを取得する。 </p>
<p>属性ストリームの作成は<code><a class="el" href="structsxsdk_1_1shape__class.html#a4b76c527c5fd568479fd57b3aaf513bb" title="カスタム属性ストリームを生成する。形状にプラグイン独自の情...">create_attribute_stream_interface_with_uuid()</a></code>, 削除は<code><a class="el" href="structsxsdk_1_1shape__class.html#a1ef5725cb185bc43328806914b128902" title="カスタム属性を削除する。">delete_attribute_with_uuid()</a></code> で行う。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stream_id</em>&nbsp;</td><td>属性ストリームの<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a010d4f7ee04996674701c479cc9e8fb3"></a><!-- doxytag: member="sxsdk::shape_class::get_axis_matrix" ref="a010d4f7ee04996674701c479cc9e8fb3" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sxsdk::mat4 sxsdk::shape_class::get_axis_matrix </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の軸を定義するマトリクスを取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ac02ee44513cc99bc33ee281562a7a57d" title="回転体の軸を定義するマトリクスを設定する。">set_axis_matrix()</a></code> で設定する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。</p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d" title="回転体の開始角度(ラジアン)を設定する。">set_revolve_from()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b" title="回転体の開始角度(ラジアン)を取得する。">get_revolve_from()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e" title="回転体の終了角度(ラジアン)を設定する。">set_revolve_to()</a>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792" title="回転体の終了角度(ラジアン)を取得する。">get_revolve_to()</a></code> で開始角度、終了角度の設定、取得する。 </p>

</div>
</div>
<a class="anchor" id="a3641b9afa55fa2b2feee8e72254e2d1f"></a><!-- doxytag: member="sxsdk::shape_class::get_ball_joint_interface" ref="a3641b9afa55fa2b2feee8e72254e2d1f" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1ball__joint__interface.html">sxsdk::ball_joint_interface</a>* sxsdk::shape_class::get_ball_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ボールジョイントを取得する。 </p>
<p>ジョイントの位置や大きさ、モーションの情報を取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a235917324e86d9cfebf7ed6e13e887ce"></a><!-- doxytag: member="sxsdk::shape_class::get_bro" ref="a235917324e86d9cfebf7ed6e13e887ce" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>* sxsdk::shape_class::get_bro </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>次の形状を取得する。 </p>
<p>次の形状がない場合は、番兵形状(<code><a class="el" href="structsxsdk_1_1sentinel__class.html">sentinel_class</a></code> を参照)が返される。 </p>

<p><a class="el" href="structsxsdk_1_1proxy__shape__class.html#a79a4ca9403758b8edd500486c146601a">sxsdk::proxy_shape_class</a>で再定義されています。</p>

</div>
</div>
<a class="anchor" id="ac1778645b664c8cde2e69ed4d8aa87d3"></a><!-- doxytag: member="sxsdk::shape_class::get_browsable" ref="ac1778645b664c8cde2e69ed4d8aa87d3" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::get_browsable </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状がブラウザウインドウに表示可能かどうかを取得する。 </p>
<p>falseが設定されると、ブラウザからは見えない形状になる。 </p>

</div>
</div>
<a class="anchor" id="a0f47b71f6e19eebdbd262d5946d5a168"></a><!-- doxytag: member="sxsdk::shape_class::get_center_point" ref="a0f47b71f6e19eebdbd262d5946d5a168" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sxsdk::vec3 sxsdk::shape_class::get_center_point </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>中心の座標値を取得する。 </p>
<p>円や球では中心の座標、線形状やポリゴンメッシュではすべてのポイントの座標の平均値が返される。</p>
<p>また、パートの場合は、パート内に含まれるすべての形状の中心の座標の平均値が返される。 </p>

</div>
</div>
<a class="anchor" id="aa152a15a733cc2dc2472986adcc71436"></a><!-- doxytag: member="sxsdk::shape_class::get_custom_joint_interface" ref="aa152a15a733cc2dc2472986adcc71436" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1custom__joint__interface.html">sxsdk::custom_joint_interface</a>* sxsdk::shape_class::get_custom_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>カスタムジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a010a77dcc709ad5531a274c790daa907"></a><!-- doxytag: member="sxsdk::shape_class::get_dad" ref="a010a77dcc709ad5531a274c790daa907" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a>* sxsdk::shape_class::get_dad </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>親の形状を取得する。 </p>
<p>親の形状がない場合(ルートパートの場合)は、NULLが返される。 </p>

</div>
</div>
<a class="anchor" id="aece36cf8036180cf0ab1b547dc6c27dd"></a><!-- doxytag: member="sxsdk::shape_class::get_disk" ref="aece36cf8036180cf0ab1b547dc6c27dd" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a>&amp; sxsdk::shape_class::get_disk </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a></code> を取得する。形状の種類が円ではない場合は例外を投げる。 </p>
<p>選択形状が円かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a9db10f634448547fe9495a6542b0efa9"></a><!-- doxytag: member="sxsdk::shape_class::get_disk" ref="a9db10f634448547fe9495a6542b0efa9" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a>&amp; sxsdk::shape_class::get_disk </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1disk__class.html">disk_class</a></code> を取得する(<code>const</code> )。形状の種類が円ではない場合は例外を投げる。 </p>
<p>選択形状が円かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="adfd66a3363fc9415a4ca8982c467b48c"></a><!-- doxytag: member="sxsdk::shape_class::get_extrude" ref="adfd66a3363fc9415a4ca8982c467b48c" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sxsdk::vec3 sxsdk::shape_class::get_extrude </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>掃引の方向と距離を取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#aa42b478384b94d85bc3fdc180878387d" title="掃引体かどうかか判定する。">is_extruded()</a></code> で掃引体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="a31fd0b8c9cb642a87b37aaed58cf322d"></a><!-- doxytag: member="sxsdk::shape_class::get_handle" ref="a31fd0b8c9cb642a87b37aaed58cf322d" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* sxsdk::shape_class::get_handle </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状のハンドルを取得する。 </p>
<p>ハンドルから<code><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a></code> を取得する場合は<code><a class="el" href="structsxsdk_1_1scene__interface.html#a13e93438943afd1766ff2b6bd5e85831" title="形状のハンドルからsxsdk::shape_class を取得する。">scene_interface::get_shape_by_handle()</a></code> 、ハンドルが正しい値かどうかをチェックする場合は<code><a class="el" href="structsxsdk_1_1scene__interface.html#ad52d84404674dbd7d79b0960aa80bc3a" title="引数で渡したハンドルが有効かどうかを判定する。">scene_interface::check_handle()</a></code> を使用する。 </p>

</div>
</div>
<a class="anchor" id="aba4f429608de18d7100470bbc3e7879f"></a><!-- doxytag: member="sxsdk::shape_class::get_light" ref="aba4f429608de18d7100470bbc3e7879f" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1light__class.html">light_class</a>&amp; sxsdk::shape_class::get_light </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1light__class.html">light_class</a></code> を取得する。形状の種類が光源ではない場合は例外を投げる。 </p>
<p>選択形状が光源かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="ad60f242552772ddfa94c585e7280d3ca"></a><!-- doxytag: member="sxsdk::shape_class::get_light" ref="ad60f242552772ddfa94c585e7280d3ca" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1light__class.html">light_class</a>&amp; sxsdk::shape_class::get_light </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1light__class.html">light_class</a></code> を取得する(<code>const</code> )。形状の種類が光源ではない場合は例外を投げる。 </p>
<p>選択形状が光源かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a64f7c8a27261d9fd54dc89b67eee93e7"></a><!-- doxytag: member="sxsdk::shape_class::get_light_effector_interface" ref="a64f7c8a27261d9fd54dc89b67eee93e7" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1light__effector__interface.html">sxsdk::light_effector_interface</a>* sxsdk::shape_class::get_light_effector_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>光源ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a07dc7fc7cc70e6e3b9c19ce69c1b30d8"></a><!-- doxytag: member="sxsdk::shape_class::get_line" ref="a07dc7fc7cc70e6e3b9c19ce69c1b30d8" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1line__class.html">line_class</a>&amp; sxsdk::shape_class::get_line </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1line__class.html">line_class</a></code> を取得する。形状の種類が線形状ではない場合は例外を投げる。 </p>
<p>選択形状が線形状かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a1ed3df762f1392e0da364de8acdbd9ca"></a><!-- doxytag: member="sxsdk::shape_class::get_line" ref="a1ed3df762f1392e0da364de8acdbd9ca" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1line__class.html">line_class</a>&amp; sxsdk::shape_class::get_line </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1line__class.html">line_class</a></code> を取得する(<code>const</code> )。形状の種類が線形状ではない場合は例外を投げる。 </p>
<p>選択形状が線形状かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a6c298a3cf84eee4c0e7d7bc463847b0c"></a><!-- doxytag: member="sxsdk::shape_class::get_linked_parent" ref="a6c298a3cf84eee4c0e7d7bc463847b0c" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>* sxsdk::shape_class::get_linked_parent </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リンクを考慮した親形状を取得する。 </p>
<p>エクスポータ、レンダラではコールバック中にカレント形状からリンクを逆に辿ることができる。それ以外の場合には、単純に親形状を返す。 </p>

<p><a class="el" href="structsxsdk_1_1proxy__shape__class.html#a74267e53900063bc5aaa7b71b3249399">sxsdk::proxy_shape_class</a>で再定義されています。</p>

</div>
</div>
<a class="anchor" id="a8f6c4c8a6e1a288c3a932bb8b9828784"></a><!-- doxytag: member="sxsdk::shape_class::get_local_to_world_matrix" ref="a8f6c4c8a6e1a288c3a932bb8b9828784" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sxsdk::mat4 sxsdk::shape_class::get_local_to_world_matrix </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ローカル座標系からワールド座標系への変換マトリクスを取得する。 </p>
<p>形状は座標値をローカル座標系で保持しているため、上位パートのマトリクス変換を考慮する必要がある場合にはワールド座標系に変換する。</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ２つの形状の中心の座標間の距離を求める。 </span>
 sxsdk::vec3 get_shape_distance (<span class="keyword">const</span> <a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape1, <span class="keyword">const</span> <a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; shape2) { 
     <span class="keyword">const</span> sxsdk::vec3 position1 = shape1.<a class="code" href="structsxsdk_1_1shape__class.html#a0f47b71f6e19eebdbd262d5946d5a168" title="中心の座標値を取得する。">get_center_point</a>() * shape1.<a class="code" href="structsxsdk_1_1shape__class.html#a8f6c4c8a6e1a288c3a932bb8b9828784" title="ローカル座標系からワールド座標系への変換マトリクスを取得する。...">get_local_to_world_matrix</a>(); 
     <span class="keyword">const</span> sxsdk::vec3 position2 = shape2.<a class="code" href="structsxsdk_1_1shape__class.html#a0f47b71f6e19eebdbd262d5946d5a168" title="中心の座標値を取得する。">get_center_point</a>() * shape2.<a class="code" href="structsxsdk_1_1shape__class.html#a8f6c4c8a6e1a288c3a932bb8b9828784" title="ローカル座標系からワールド座標系への変換マトリクスを取得する。...">get_local_to_world_matrix</a>(); 
  
     <span class="keywordflow">return</span> position2 - position1; 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a17133749fde8ae3e1b5a15149cc11a98"></a><!-- doxytag: member="sxsdk::shape_class::get_master_image" ref="a17133749fde8ae3e1b5a15149cc11a98" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a>&amp; sxsdk::shape_class::get_master_image </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a></code> を取得する。形状の種類がイメージオブジェクトではない場合は例外を投げる。 </p>
<p>選択形状がイメージオブジェクトかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="ad013928d420167976bec808502b5a64b"></a><!-- doxytag: member="sxsdk::shape_class::get_master_image" ref="ad013928d420167976bec808502b5a64b" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a>&amp; sxsdk::shape_class::get_master_image </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1master__image__class.html">master_image_class</a></code> を取得する(<code>const</code> )。形状の種類がイメージオブジェクトではない場合は例外を投げる。 </p>
<p>選択形状がイメージオブジェクトかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="ab724792f02a0b47fbe6dbf9e10ecc46d"></a><!-- doxytag: member="sxsdk::shape_class::get_modifiable" ref="ab724792f02a0b47fbe6dbf9e10ecc46d" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::get_modifiable </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状がモディファイ可能かどうかを取得する。 </p>
<p>falseが設定されると、モディファイモード時にコントロールポイントが表示されなくなる。 </p>

</div>
</div>
<a class="anchor" id="a89d3139987ef5c5b1f9d02764ac0831d"></a><!-- doxytag: member="sxsdk::shape_class::get_morph_effector_interface" ref="a89d3139987ef5c5b1f9d02764ac0831d" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1morph__effector__interface.html">sxsdk::morph_effector_interface</a>* sxsdk::shape_class::get_morph_effector_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>変形ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="abfee2d534fcf9944b649873b51f7edfa"></a><!-- doxytag: member="sxsdk::shape_class::get_motion_interface" ref="abfee2d534fcf9944b649873b51f7edfa" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1motion__interface.html">sxsdk::motion_interface</a>* sxsdk::shape_class::get_motion_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1motion__interface.html">motion_interface</a></code> を取得する。 </p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a4b4993a71180f51b1ddc66cad131cf57"></a><!-- doxytag: member="sxsdk::shape_class::get_name" ref="a4b4993a71180f51b1ddc66cad131cf57" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* sxsdk::shape_class::get_name </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状の名前を取得する。 </p>
<p>0を渡すとデフォルト名が設定される。 </p>

</div>
</div>
<a class="anchor" id="a2cd98e4f6c47fad561e447a77765481e"></a><!-- doxytag: member="sxsdk::shape_class::get_nonnil_surface_interface" ref="a2cd98e4f6c47fad561e447a77765481e" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a>* sxsdk::shape_class::get_nonnil_surface_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>表面材質を取得する。 </p>
<p>表面材質が存在しない場合には自動的に生成される。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a1a7bc16788d829d9f233abcf4d841477"></a><!-- doxytag: member="sxsdk::shape_class::get_number_of_points" ref="a1a7bc16788d829d9f233abcf4d841477" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_number_of_points </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ポイントの数を取得する。 </p>
<p>線形状の場合は接線ハンドル、交差方向接線ハンドルも１つのポイントとして扱うため、コントロールポイントの数の５倍を返す。</p>
<p>コントロールポイントの数を取得する場合は、<code><a class="el" href="structsxsdk_1_1shape__class.html#a63db5b00d013ef2a50482f723488bbf9" title="コントロールポイントの総数を取得する。">get_total_number_of_control_points()</a></code> を使用する。 </p>

</div>
</div>
<a class="anchor" id="ae2bde59792a6745f03cd3705ca416484"></a><!-- doxytag: member="sxsdk::shape_class::get_ordinal" ref="ae2bde59792a6745f03cd3705ca416484" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_ordinal </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状／パートの序数を取得する。 </p>
<p>序数はブラウザ上の形状の順序から決定される。ブラウザで形状の順序を変更すると序数も変更される。</p>
<p>シーンを閉じて開きなおしたり、形状の削除をアンドゥした場合など、<code><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a></code> が再生成される場合にも値が変わらない利点がある。</p>
<p><code><a class="el" href="structsxsdk_1_1scene__interface.html#abd0ba9b6b8ecedf5321958184cfe2740" title="序数で指定された形状を取得する。">scene_interface::get_shape_by_ordinal()</a></code> で序数から<code><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>を取得できる。</code> </p>

</div>
</div>
<a class="anchor" id="ae2ad50ef25998543e114f31a7ceedc5b"></a><!-- doxytag: member="sxsdk::shape_class::get_parent" ref="ae2ad50ef25998543e114f31a7ceedc5b" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>* sxsdk::shape_class::get_parent </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>親の形状を取得する。 </p>
<p>親の形状がない場合は、NULLが返される。</p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a010a77dcc709ad5531a274c790daa907" title="親の形状を取得する。">get_dad()</a></code> と異なり、<code><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a></code> のポインタを返す。 </p>

<p><a class="el" href="structsxsdk_1_1proxy__shape__class.html#addf98bb7e6bb0d112981664f95d13a0a">sxsdk::proxy_shape_class</a>で再定義されています。</p>

</div>
</div>
<a class="anchor" id="af549ebc37d1f503cdd1426eb06f27fa3"></a><!-- doxytag: member="sxsdk::shape_class::get_part" ref="af549ebc37d1f503cdd1426eb06f27fa3" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a>&amp; sxsdk::shape_class::get_part </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1part__class.html">part_class</a></code> を取得する。形状の種類がパートではない場合は例外を投げる。 </p>
<p>選択形状がパートかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> 、または<code><a class="el" href="structsxsdk_1_1shape__class.html#ab260b76a73175803efa58300bb8cb56e" title="階層下に形状を含むことができるかどうか。(パートかどうか)か判定する...">is_container()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="ae0edc8f16bac8ec43b69f58ff044f5d1"></a><!-- doxytag: member="sxsdk::shape_class::get_part" ref="ae0edc8f16bac8ec43b69f58ff044f5d1" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1part__class.html">part_class</a>&amp; sxsdk::shape_class::get_part </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1part__class.html">part_class</a></code> を取得する(<code>const</code> )。形状の種類がパートではない場合は例外を投げる。 </p>
<p>選択形状がパートかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> 、または<code><a class="el" href="structsxsdk_1_1shape__class.html#ab260b76a73175803efa58300bb8cb56e" title="階層下に形状を含むことができるかどうか。(パートかどうか)か判定する...">is_container()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a46ebf92c3c4dbd3af3e2f65fe2ba8375"></a><!-- doxytag: member="sxsdk::shape_class::get_path_joint_interface" ref="a46ebf92c3c4dbd3af3e2f65fe2ba8375" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1path__joint__interface.html">sxsdk::path_joint_interface</a>* sxsdk::shape_class::get_path_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パスジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="aad3779fc59e01104051cf980d11357bc"></a><!-- doxytag: member="sxsdk::shape_class::get_path_replicator_interface" ref="aad3779fc59e01104051cf980d11357bc" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxsdk_1_1path__replicator__interface.html">sxsdk::path_replicator_interface</a>* sxsdk::shape_class::get_path_replicator_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>パスリプリケータを取得する。 </p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a4a770995862b16960db2e4ff23696606"></a><!-- doxytag: member="sxsdk::shape_class::get_polygon_mesh" ref="a4a770995862b16960db2e4ff23696606" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a>&amp; sxsdk::shape_class::get_polygon_mesh </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a></code> を取得する。形状の種類がポリゴンメッシュではない場合は例外を投げる。 </p>
<p>選択形状がポリゴンメッシュかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="aa13d4845d8554178d6987c97f33f9e8c"></a><!-- doxytag: member="sxsdk::shape_class::get_polygon_mesh" ref="aa13d4845d8554178d6987c97f33f9e8c" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a>&amp; sxsdk::shape_class::get_polygon_mesh </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1polygon__mesh__class.html">polygon_mesh_class</a></code> を取得する(<code>const</code> )。形状の種類がポリゴンメッシュではない場合は例外を投げる。 </p>
<p>選択形状がポリゴンメッシュかどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a0a472440060766e64740d230e64bc927"></a><!-- doxytag: member="sxsdk::shape_class::get_proxy_shape" ref="a0a472440060766e64740d230e64bc927" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a>&amp; sxsdk::shape_class::get_proxy_shape </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>プロクシ形状を取得する。 </p>
<p>レンダラプラグイン、エクスポータプラグインのみで使用可能。<code><a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a></code> を使用すると、リンク形状を展開した状態のシーンの階層構造を取得できる。 </p>

</div>
</div>
<a class="anchor" id="a7b2bf3bac1ac1fd16b30ad9dfbfe9864"></a><!-- doxytag: member="sxsdk::shape_class::get_proxy_shape" ref="a7b2bf3bac1ac1fd16b30ad9dfbfe9864" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a>&amp; sxsdk::shape_class::get_proxy_shape </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>プロクシ形状を取得する。(const) </p>
<p>レンダラプラグイン、エクスポータプラグインのみで使用可能。<code><a class="el" href="structsxsdk_1_1proxy__shape__class.html">proxy_shape_class</a></code> を使用すると、リンク形状を展開した状態のシーンの階層構造を取得できる。 </p>

</div>
</div>
<a class="anchor" id="aa1530d962009930861be2d9f40a01c3b"></a><!-- doxytag: member="sxsdk::shape_class::get_related_shapes" ref="aa1530d962009930861be2d9f40a01c3b" args="(const sx::uuid_class &amp;relation_id, sxsdk::shape_class **shapes=0, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_related_shapes </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>relation_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> **&nbsp;</td>
          <td class="paramname"> <em>shapes</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a></code> で関連付けされた形状のリストを取得する。 </p>
<p>関連付けは双方向で行われるので、<code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a>を呼び出した形状と、その引数に渡した形状のどちらからでも参照することができる。<em>shapes</em> に0を渡すと、<em>link_id</em> で関連付けられた形状の数を取得できる。</code> </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relation_id</em>&nbsp;</td><td>関連付けの種類を識別する<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shapes</em>&nbsp;</td><td>関連付けされた形状のリストを格納する配列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae617d8d3d40634a600ad5e8111490768"></a><!-- doxytag: member="sxsdk::shape_class::get_render_flag" ref="ae617d8d3d40634a600ad5e8111490768" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_render_flag </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>レンダリング対象とするかどうかを取得する。 </p>
<p>-1: 継承（デフォルト）、0: レンダリングしない、1: 常にレンダリング</p>
<p>継承が設定されている場合は上位パートの設定が有効になる。 </p>

</div>
</div>
<a class="anchor" id="a00b22b59264d309ea8198c7822782e01"></a><!-- doxytag: member="sxsdk::shape_class::get_rendering" ref="a00b22b59264d309ea8198c7822782e01" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_rendering </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>レンダリングの対象となるかどうかを取得する。 </p>
<p>-1: 継承, 0: レンダリングしない, 1: 常にレンダリング。</p>
<p>リンクから参照されている場合もあるため、形状を指定しただけでは実際にその形状がレンダリングの対象となるかどうかは判定できない。rendering属性は単純に３値のフラグで、その値が-1の場合には、実際にどういう経路で（リンクを介して）継承されるのかはプラグイン自身で判定する必要がある。</p>
<p>レンダリング中であれば、<code><a class="el" href="structsxsdk_1_1rendering__context__interface.html#adab29b0b1b7f3855c0b26508fceec02c" title="形状がレンダリングの対象となっているかどうかを返す。">rendering_context_interface::get_rendering_flag()</a></code> でレンダリング対象かどうかを判定できる。 </p>

</div>
</div>
<a class="anchor" id="ae019a1a3be32d6615f4c4f5e71a01b1b"></a><!-- doxytag: member="sxsdk::shape_class::get_revolve_from" ref="ae019a1a3be32d6615f4c4f5e71a01b1b" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float sxsdk::shape_class::get_revolve_from </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の開始角度(ラジアン)を取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e" title="回転体の終了角度(ラジアン)を設定する。">set_revolve_to()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792" title="回転体の終了角度(ラジアン)を取得する。">get_revolve_to()</a> で終了角度を設定、取得する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="a9ec29179a5703dc9140a835855714792"></a><!-- doxytag: member="sxsdk::shape_class::get_revolve_to" ref="a9ec29179a5703dc9140a835855714792" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual float sxsdk::shape_class::get_revolve_to </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の終了角度(ラジアン)を取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d" title="回転体の開始角度(ラジアン)を設定する。">set_revolve_from()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b" title="回転体の開始角度(ラジアン)を取得する。">get_revolve_from()</a> で開始角度を設定、取得する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="a4ee3083613ad4e97d2726d2746878cfb"></a><!-- doxytag: member="sxsdk::shape_class::get_rotator_joint_interface" ref="a4ee3083613ad4e97d2726d2746878cfb" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1rotator__joint__interface.html">sxsdk::rotator_joint_interface</a>* sxsdk::shape_class::get_rotator_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a7264f015119bd6c274415dc221adf164"></a><!-- doxytag: member="sxsdk::shape_class::get_scale_joint_interface" ref="a7264f015119bd6c274415dc221adf164" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1scale__joint__interface.html">sxsdk::scale_joint_interface</a>* sxsdk::shape_class::get_scale_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>拡大縮小ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a476057cf7e7c4797c0c5b5c41dc347b9"></a><!-- doxytag: member="sxsdk::shape_class::get_scene_interface" ref="a476057cf7e7c4797c0c5b5c41dc347b9" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1scene__interface.html">sxsdk::scene_interface</a>* sxsdk::shape_class::get_scene_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状が属するシーンを取得する。 </p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a02d6a95c0fccde11cf1e2829f698e977"></a><!-- doxytag: member="sxsdk::shape_class::get_sequence_joint_matrix" ref="a02d6a95c0fccde11cf1e2829f698e977" args="(float sequence_value, void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sxsdk::mat4 sxsdk::shape_class::get_sequence_joint_matrix </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sequence_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>frame</em> で渡したシーケンス値における、ジョイント変換マトリクス </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sequence_value</em>&nbsp;</td><td>シーケンス値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28a6e67fd2b4f903ffee23f816514c13"></a><!-- doxytag: member="sxsdk::shape_class::get_sequence_local_to_world_matrix" ref="a28a6e67fd2b4f903ffee23f816514c13" args="(float sequence_value, void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sxsdk::mat4 sxsdk::shape_class::get_sequence_local_to_world_matrix </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sequence_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>frame</em> で渡したシーケンス値における、ローカル座標系からワールド座標系への変換マトリクス </p>
<p>形状は座標値をローカル座標系で保持しているため、上位パートのマトリクス変換を考慮する必要がある場合にはワールド座標系に変換する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sequence_value</em>&nbsp;</td><td>シーケンス値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf03b9397a5a3855065822aa6bc0e8cb"></a><!-- doxytag: member="sxsdk::shape_class::get_sequence_transformation" ref="adf03b9397a5a3855065822aa6bc0e8cb" args="(float sequence_value, void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sxsdk::mat4 sxsdk::shape_class::get_sequence_transformation </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sequence_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>frame</em> で渡したシーケンス値における、形状の変換マトリクスを返す。 </p>
<p>ジョイント、スキンの影響を考慮した形状の変換マトリクス</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sequence_value</em>&nbsp;</td><td>シーケンス値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb478d99129a1b3be42bdd7e488dd0b1"></a><!-- doxytag: member="sxsdk::shape_class::get_sequence_world_to_local_matrix" ref="aeb478d99129a1b3be42bdd7e488dd0b1" args="(float sequence_value, void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sxsdk::mat4 sxsdk::shape_class::get_sequence_world_to_local_matrix </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>sequence_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><em>frame</em> で渡したシーケンス値における、ワールド座標系からローカル座標系への変換マトリクス </p>
<p>形状は座標値をローカル座標系で保持しているため、上位パートのマトリクス変換を考慮する必要がある場合にはワールド座標系に変換する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>sequence_value</em>&nbsp;</td><td>シーケンス値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8de1bdcb5a9462dee49ffd8122d6e0af"></a><!-- doxytag: member="sxsdk::shape_class::get_shadow_catcher" ref="a8de1bdcb5a9462dee49ffd8122d6e0af" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_shadow_catcher </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>シャドウキャッチャーを取得する。 </p>
<p>-1: 継承, 0: レンダリングする, 1: 影のみをレンダリング。 </p>

</div>
</div>
<a class="anchor" id="a46e765a64702e7a1ccce6b51bbc5512e"></a><!-- doxytag: member="sxsdk::shape_class::get_sis" ref="a46e765a64702e7a1ccce6b51bbc5512e" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>* sxsdk::shape_class::get_sis </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>前の形状を取得する。 </p>
<p>前の形状がない場合は、番兵形状(<code><a class="el" href="structsxsdk_1_1sentinel__class.html">sentinel_class</a></code> を参照) が返される。 </p>

<p><a class="el" href="structsxsdk_1_1proxy__shape__class.html#a65a24fdca13dd6ea55d4f2105082000d">sxsdk::proxy_shape_class</a>で再定義されています。</p>

</div>
</div>
<a class="anchor" id="a94a8c1504bf7a0361c6e14ace129b147"></a><!-- doxytag: member="sxsdk::shape_class::get_skin" ref="a94a8c1504bf7a0361c6e14ace129b147" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1skin__class.html">skin_class</a>&amp; sxsdk::shape_class::get_skin </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>頂点を持たない、または１つだけの形状のスキンを取得する。 </p>
<p>パート、ジョイント、円、球、リンクなどで使用。</p>
<p>線形状は<code><a class="el" href="structsxsdk_1_1control__point__class.html#a15318711b61a6834947ffd7765eee686" title="コントロールポイントにバインドされた skin_classを取得する。...">control_point_class::get_skin()</a></code>, ポリゴンメッシュは<code><a class="el" href="structsxsdk_1_1vertex__class.html#a198772f427c9b81e38475e5cd01bf5a9" title="skin_class を取得する。">vertex_class::get_skin()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="aa76770fb2a400a7b1855814084bd24ac"></a><!-- doxytag: member="sxsdk::shape_class::get_slider_joint_interface" ref="aa76770fb2a400a7b1855814084bd24ac" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1slider__joint__interface.html">sxsdk::slider_joint_interface</a>* sxsdk::shape_class::get_slider_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>直線移動ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="aab98263026c91dd4ce31cbc69748aefa"></a><!-- doxytag: member="sxsdk::shape_class::get_son" ref="aab98263026c91dd4ce31cbc69748aefa" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>* sxsdk::shape_class::get_son </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>子の番兵形状(<code><a class="el" href="structsxsdk_1_1sentinel__class.html">sentinel_class</a></code> を参照)を取得する。 </p>
<p>番兵形状はパート内の形状の終端を表し、空のパートにも必ず存在する。番兵形状の次の形状(<code><a class="el" href="structsxsdk_1_1shape__class.html#a235917324e86d9cfebf7ed6e13e887ce" title="次の形状を取得する。">get_bro()</a></code>) はパート内の一番上、前の形状(<code><a class="el" href="structsxsdk_1_1shape__class.html#a46e765a64702e7a1ccce6b51bbc5512e" title="前の形状を取得する。">get_sis()</a></code>) はパート内の一番下の形状になる。 </p>

</div>
</div>
<a class="anchor" id="ac360965b29d587204e1bed5262ce690f"></a><!-- doxytag: member="sxsdk::shape_class::get_sphere" ref="ac360965b29d587204e1bed5262ce690f" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a>&amp; sxsdk::shape_class::get_sphere </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a></code> を取得する。形状の種類が球ではない場合は例外を投げる。 </p>
<p>選択形状が球かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="aceadb2af17ec5109c915c748aa034a24"></a><!-- doxytag: member="sxsdk::shape_class::get_sphere" ref="aceadb2af17ec5109c915c748aa034a24" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a>&amp; sxsdk::shape_class::get_sphere </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1sphere__class.html">sphere_class</a></code> を取得する(<code>const</code> )。形状の種類が球ではない場合は例外を投げる。 </p>
<p>選択形状が球かどうかは、<code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">get_type()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a0ddbc11035d029929fafb16259df7a56"></a><!-- doxytag: member="sxsdk::shape_class::get_surface" ref="a0ddbc11035d029929fafb16259df7a56" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1surface__class.html">surface_class</a>* sxsdk::shape_class::get_surface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>表面材質を取得する。 </p>
<p>表面材質が存在しない場合にはnilが返される。 </p>

</div>
</div>
<a class="anchor" id="abff3583d7c8ec5f97cfd1faeb79a6adc"></a><!-- doxytag: member="sxsdk::shape_class::get_surface_reference" ref="abff3583d7c8ec5f97cfd1faeb79a6adc" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsxsdk_1_1surface__class.html">surface_class</a>&amp; sxsdk::shape_class::get_surface_reference </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>表面材質を取得する。 </p>
<p>表面材質が存在しない場合には空の表面材質を作成する。 </p>

</div>
</div>
<a class="anchor" id="ae4d7e9a14dc205ce3a9f279bfc071553"></a><!-- doxytag: member="sxsdk::shape_class::get_switch_effector_interface" ref="ae4d7e9a14dc205ce3a9f279bfc071553" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1switch__effector__interface.html">sxsdk::switch_effector_interface</a>* sxsdk::shape_class::get_switch_effector_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>スイッチジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="a04b07ddaaf0966ee1af9215313dc8c20"></a><!-- doxytag: member="sxsdk::shape_class::get_tag_boolValue" ref="a04b07ddaaf0966ee1af9215313dc8c20" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxsdk::shape_class::get_tag_boolValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして形状に登録されている値を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a472aa41278311f7f77fced2c6ec522f2"></a><!-- doxytag: member="sxsdk::shape_class::get_tag_doubleValue" ref="a472aa41278311f7f77fced2c6ec522f2" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double sxsdk::shape_class::get_tag_doubleValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして形状に登録されている値を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6bba70e96cdf72a492885a9dcac88491"></a><!-- doxytag: member="sxsdk::shape_class::get_tag_floatValue" ref="a6bba70e96cdf72a492885a9dcac88491" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float sxsdk::shape_class::get_tag_floatValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして形状に登録されている値を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabeeca6133d3f0d7487f40ed75f6db3e"></a><!-- doxytag: member="sxsdk::shape_class::get_tag_intValue" ref="aabeeca6133d3f0d7487f40ed75f6db3e" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sxsdk::shape_class::get_tag_intValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして形状に登録されている値を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7d223f378bca53e76e8fcbe848fa707"></a><!-- doxytag: member="sxsdk::shape_class::get_tag_stringValue" ref="ad7d223f378bca53e76e8fcbe848fa707" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* sxsdk::shape_class::get_tag_stringValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして形状に登録されている値を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63db5b00d013ef2a50482f723488bbf9"></a><!-- doxytag: member="sxsdk::shape_class::get_total_number_of_control_points" ref="a63db5b00d013ef2a50482f723488bbf9" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::shape_class::get_total_number_of_control_points </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>コントロールポイントの総数を取得する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a9c39b3abcad65b2f9b536f59a43a892e" title="引数iで指定されたコントロールポイントの参照を取得する。...">control_point()</a></code> でコントロールポイントを取得する。 </p>

</div>
</div>
<a class="anchor" id="a8ca83886895acd5efac10d6f75e700f2"></a><!-- doxytag: member="sxsdk::shape_class::get_uniscale_joint_interface" ref="a8ca83886895acd5efac10d6f75e700f2" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1uniscale__joint__interface.html">sxsdk::uniscale_joint_interface</a>* sxsdk::shape_class::get_uniscale_joint_interface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>均等拡大縮小ジョイントを取得する。 </p>
<p>ジョイント値やモーションの情報を設定、取得する場合は<code><a class="el" href="structsxsdk_1_1shape__class.html#abfee2d534fcf9944b649873b51f7edfa" title="motion_interface を取得する。">get_motion_interface()</a></code> を使用する。</p>
<p>オブジェクトの確実な破棄のために<code><a class="el" href="classcompointer.html" title="*_interfaceクラスのオブジェクトを指す参照カウントスマートポインタ。...">compointer</a></code> を使用する(<a class="el" href="memorymanagement.html">メモリ管理</a> )。 </p>

</div>
</div>
<a class="anchor" id="ad3c84cbdc78f1b5b827d8aa80136b056"></a><!-- doxytag: member="sxsdk::shape_class::get_world_to_local_matrix" ref="ad3c84cbdc78f1b5b827d8aa80136b056" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual sxsdk::mat4 sxsdk::shape_class::get_world_to_local_matrix </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ワールド座標系からローカル座標系への変換マトリクスを取得する。 </p>
<p>形状は座標値をローカル座標系で保持しているため、上位パートのマトリクス変換を考慮する必要がある場合にはワールド座標系に変換する。</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// ワールド座標系で座標を指定して、指定形状と同階層に球を作成する。 </span>
 sphere_class&amp; create_sphere_at (scene_interface* scene, <span class="keyword">const</span> <span class="keywordtype">char</span>* as, <span class="keyword">const</span> sxsdk::vec3&amp; position, <span class="keywordtype">float</span> r, <a class="code" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a>&amp; at) { 
     <span class="keyword">const</span> sxsdk::vec3 global_position = position * at.<a class="code" href="structsxsdk_1_1shape__class.html#ad3c84cbdc78f1b5b827d8aa80136b056" title="ワールド座標系からローカル座標系への変換マトリクスを取得する。...">get_world_to_local_matrix</a>(); 
  
     scene-&gt;begin_creating_at(&amp;at); 
     sphere_class&amp; <a class="code" href="namespacesxsdk_1_1enums.html#aa6cc70b74636bfbf63bbfb8a2da2ce52a747a9fb1941f275af51b7be34d9e7630" title="球">sphere</a> = scene-&gt;create_sphere(as, global_position, r); 
     scene-&gt;end_creating(); 
  
     <span class="keywordflow">return</span> sphere; 
 } 
</pre></div> 
</div>
</div>
<a class="anchor" id="a30e22aa4205d3661c64182650bd6f0ad"></a><!-- doxytag: member="sxsdk::shape_class::has_bro" ref="a30e22aa4205d3661c64182650bd6f0ad" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_bro </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>次の形状を持っているか判定する。 </p>
<p>次の形状は<code><a class="el" href="structsxsdk_1_1shape__class.html#a235917324e86d9cfebf7ed6e13e887ce" title="次の形状を取得する。">get_bro()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="ada131e151bf013510d11ab8f891c31c8"></a><!-- doxytag: member="sxsdk::shape_class::has_dad" ref="ada131e151bf013510d11ab8f891c31c8" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_dad </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>親の形状を持っているか判定する。 </p>
<p>親の形状は<code><a class="el" href="structsxsdk_1_1shape__class.html#a010a77dcc709ad5531a274c790daa907" title="親の形状を取得する。">get_dad()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a840a0bd2103ee51e8e579e928ed38e55"></a><!-- doxytag: member="sxsdk::shape_class::has_motion" ref="a840a0bd2103ee51e8e579e928ed38e55" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_motion </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>モーションを設定できる形状を持っているか判定する。 </p>
<p>モーションはジョイント、カメラに対して設定することができる。 </p>

</div>
</div>
<a class="anchor" id="a8f0b3077baa9d8a149629d5447566ad0"></a><!-- doxytag: member="sxsdk::shape_class::has_sis" ref="a8f0b3077baa9d8a149629d5447566ad0" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_sis </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>前の形状を持っているか判定する。 </p>
<p>前の形状は<code><a class="el" href="structsxsdk_1_1shape__class.html#a46e765a64702e7a1ccce6b51bbc5512e" title="前の形状を取得する。">get_sis()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a114c71dbb4d26d3ecf95a48a7e610644"></a><!-- doxytag: member="sxsdk::shape_class::has_son" ref="a114c71dbb4d26d3ecf95a48a7e610644" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_son </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>（番兵でない）子の形状を持っているか判定する。 </p>
<p>子の形状は<code><a class="el" href="structsxsdk_1_1shape__class.html#a114c71dbb4d26d3ecf95a48a7e610644" title="（番兵でない）子の形状を持っているか判定する。">has_son()</a></code> で取得する。 </p>

</div>
</div>
<a class="anchor" id="a9bb71ee890cf1b9ec3644f9e0e5cf6b5"></a><!-- doxytag: member="sxsdk::shape_class::has_special_character" ref="a9bb71ee890cf1b9ec3644f9e0e5cf6b5" args="(char c, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_special_character </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状名に引数<em>c</em> で渡した特殊記号があるかどうか。 </p>
<p>特殊記号のリストは、<code><a class="el" href="structsxsdk_1_1shade__interface.html#a33e927156dacfd4c3c110ef1489945b7" title="疑似集合演算などに使われる特殊文字のすべての文字列を取得する。...">shade_interface::get_special_characters()</a></code> で取得できる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>ブーリアン記号などの特殊記号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac92ae88654791460459a1795842a940b"></a><!-- doxytag: member="sxsdk::shape_class::has_surface" ref="ac92ae88654791460459a1795842a940b" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_surface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>表面材質を持っているかどうか </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a0ddbc11035d029929fafb16259df7a56" title="表面材質を取得する。">get_surface()</a></code> で表面材質を取得することができる。 </p>

</div>
</div>
<a class="anchor" id="ae72d8aa677b7ea42713a83ef4440af9c"></a><!-- doxytag: member="sxsdk::shape_class::has_symbol" ref="ae72d8aa677b7ea42713a83ef4440af9c" args="(char symbol, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::has_symbol </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状名に引数<em>c</em> で渡した特殊記号があるかどうか。 </p>
<p>特殊記号のリストは、<code><a class="el" href="structsxsdk_1_1shade__interface.html#a33e927156dacfd4c3c110ef1489945b7" title="疑似集合演算などに使われる特殊文字のすべての文字列を取得する。...">shade_interface::get_special_characters()</a></code> で取得できる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>symbol</em>&nbsp;</td><td>ブーリアン記号などの特殊記号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09f473ff12a67ac5e72dc74be795d124"></a><!-- doxytag: member="sxsdk::shape_class::has_tag" ref="a09f473ff12a67ac5e72dc74be795d124" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sxsdk::shape_class::has_tag </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定されたtag名称が形状に設定されているか </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a616f7a8f37733b0f1a2aa70e90dfe34c"></a><!-- doxytag: member="sxsdk::shape_class::hide" ref="a616f7a8f37733b0f1a2aa70e90dfe34c" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::hide </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を隠す。 </p>
<p>図形メニューから「非表示（選択形状）」を選択したときと同じ動作をする。 </p>

</div>
</div>
<a class="anchor" id="a312ba2011231d799a170aa14d92a55ae"></a><!-- doxytag: member="sxsdk::shape_class::inactivate" ref="a312ba2011231d799a170aa14d92a55ae" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::inactivate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を選択解除する。 </p>
<p>複数選択されれている形状のうち、１つの形状だけを選択解除する場合に使用。</p>
<p>Shadeでは形状が１つも選択されていない状態は存在しないため、選択形状が一つだけのときは何もしない。 </p>

</div>
</div>
<a class="anchor" id="ab260b76a73175803efa58300bb8cb56e"></a><!-- doxytag: member="sxsdk::shape_class::is_container" ref="ab260b76a73175803efa58300bb8cb56e" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::is_container </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>階層下に形状を含むことができるかどうか。(パートかどうか)か判定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ae2c3e3c08b3bf23288e516b2686fd6e9" title="形状の種類 (enums::shape_type を参照)を取得する。">sxsdk::shape_class::get_type()</a></code>, <code><a class="el" href="structsxsdk_1_1part__class.html#a241c9e440c39581633a57a0c2842e5ee" title="パートの種類 (enums::part_type を参照)を取得する。">part_class::get_part_type()</a></code> で形状の種類を取得できる。 </p>

</div>
</div>
<a class="anchor" id="a5591bef90d736888f698d072c1264b3c"></a><!-- doxytag: member="sxsdk::shape_class::is_control_point_selected" ref="a5591bef90d736888f698d072c1264b3c" args="(int i, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::is_control_point_selected </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>コントロールポイントが選択されているかどうか取得する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>コントロールポイントの番号 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa42b478384b94d85bc3fdc180878387d"></a><!-- doxytag: member="sxsdk::shape_class::is_extruded" ref="aa42b478384b94d85bc3fdc180878387d" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::is_extruded </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>掃引体かどうかか判定する。 </p>
<p>掃引距離は<code><a class="el" href="structsxsdk_1_1shape__class.html#a74393c305bca1e6b397d9ceff2e52127" title="掃引の方向と距離を設定する。">set_extrude()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#adfd66a3363fc9415a4ca8982c467b48c" title="掃引の方向と距離を取得する。">get_extrude()</a></code> で設定、取得する。 </p>

</div>
</div>
<a class="anchor" id="a5efe1dfae7d7d5e55c70c1e9ea0f95d2"></a><!-- doxytag: member="sxsdk::shape_class::is_revolved" ref="a5efe1dfae7d7d5e55c70c1e9ea0f95d2" args="(void *=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::shape_class::is_revolved </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体かどうかか判定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#ac02ee44513cc99bc33ee281562a7a57d" title="回転体の軸を定義するマトリクスを設定する。">set_axis_matrix()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a010d4f7ee04996674701c479cc9e8fb3" title="回転体の軸を定義するマトリクスを取得する。">get_axis_matrix()</a></code> で回転体の軸を定義するマトリクスを設定、取得する。</p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d" title="回転体の開始角度(ラジアン)を設定する。">set_revolve_from()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b" title="回転体の開始角度(ラジアン)を取得する。">get_revolve_from()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e" title="回転体の終了角度(ラジアン)を設定する。">set_revolve_to()</a>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792" title="回転体の終了角度(ラジアン)を取得する。">get_revolve_to()</a></code> で開始角度、終了角度の設定、取得する。 </p>

</div>
</div>
<a class="anchor" id="aef35a392a86b34e36952ce020a541630"></a><!-- doxytag: member="sxsdk::shape_class::link_object" ref="aef35a392a86b34e36952ce020a541630" args="(const sxsdk::mat4 &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1part__class.html">part_class</a>&amp; sxsdk::shape_class::link_object </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リンク形状を作成する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>元形状に対する変換行列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8f6cc4c74b70b22294803425ebd9f06"></a><!-- doxytag: member="sxsdk::shape_class::make_line_wireframe" ref="af8f6cc4c74b70b22294803425ebd9f06" args="(const sxsdk::mat4 &amp;mat, int n, const sxsdk::vec3 *p, bool closed=false, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::make_line_wireframe </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>closed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>線のワイヤーフレームを作成する。 </p>
<p><code><a class="el" href="structsxsdk_1_1plugin__interface.html#a13ed7f8d0cce9838504302688caee395" title="オーバライド可。仮想関数。attribute_interface, creator_interface, modifier_interface...">plugin_interface::make_wireframe()</a></code> コールバック内で呼び出すことでワイヤフレームが描画される。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>ローカル座標系からワールド座標系への変換マトリクス。通常はmake_wireframeの引数として渡された変換マトリクスをそのまま使う。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>ワイヤフレームのポイント数 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>p</em>&nbsp;</td><td>ワイヤフレームのポイント座標値の列へのポインタ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closed</em>&nbsp;</td><td>線が閉じているか </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8459ffbb0bfac14fba6361736a6fb9d"></a><!-- doxytag: member="sxsdk::shape_class::make_sphere_wireframe" ref="ac8459ffbb0bfac14fba6361736a6fb9d" args="(const sxsdk::mat4 &amp;mat, const sxsdk::mat4 &amp;trans, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::make_sphere_wireframe </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>球のワイヤーフレームを作成する。 </p>
<p><code><a class="el" href="structsxsdk_1_1plugin__interface.html#a13ed7f8d0cce9838504302688caee395" title="オーバライド可。仮想関数。attribute_interface, creator_interface, modifier_interface...">plugin_interface::make_wireframe()</a></code> コールバック内で呼び出すことでワイヤフレームが描画される。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>mat</em>&nbsp;</td><td>ローカル座標系からワールド座標系への変換マトリクス。通常はmake_wireframeの引数として渡された変換マトリクスをそのまま使う。 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>球を定義する変換マトリクス </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8287e0ec7a3f5771d44ced0d8d84b28"></a><!-- doxytag: member="sxsdk::shape_class::move_links" ref="af8287e0ec7a3f5771d44ced0d8d84b28" args="(const sxsdk::mat4 &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::move_links </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>リンク先の形状に影響を与えないようにリンク形状を移動する。 </p>
<p>マスター形状に対して<code><a class="el" href="structsxsdk_1_1shape__class.html#a8073a774415254611695f128a24dc1fb" title="形状を移動する。">move_object()</a></code> などで変換を掛けると、リンク形状も追従して変換される。この関数は逆行列を掛けてリンクへの変換を相殺し、マスター形状にのみ変換させる場合に用いる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>移動のための変換行列 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8073a774415254611695f128a24dc1fb"></a><!-- doxytag: member="sxsdk::shape_class::move_object" ref="a8073a774415254611695f128a24dc1fb" args="(const sxsdk::mat4 &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::move_object </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>形状移動のための変換マトリクス </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4af76b72ae4cd6902f19a4d1ec6157a"></a><!-- doxytag: member="sxsdk::shape_class::place" ref="aa4af76b72ae4cd6902f19a4d1ec6157a" args="(sxsdk::shape_class &amp;at, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を挿入点の後に移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>at</em>&nbsp;</td><td>挿入点対象形状 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96c8173631adbdf454534debbbdc855e"></a><!-- doxytag: member="sxsdk::shape_class::place_brother" ref="a96c8173631adbdf454534debbbdc855e" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::place_brother </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状をn個後に移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>同階層n個後 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a729fe7fa976bda3543b2529a366a0aac"></a><!-- doxytag: member="sxsdk::shape_class::place_child" ref="a729fe7fa976bda3543b2529a366a0aac" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::place_child </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を1階層下のn番目の位置に移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>1階層下のn番目 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3e2ebdc5147f4345a57147369bb852a"></a><!-- doxytag: member="sxsdk::shape_class::place_parent" ref="aa3e2ebdc5147f4345a57147369bb852a" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::place_parent </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状をn階層上に移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>n階上階層 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b79d73557adbd8decc1019eee838ff2"></a><!-- doxytag: member="sxsdk::shape_class::place_sister" ref="a6b79d73557adbd8decc1019eee838ff2" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::place_sister </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状をn個前に移動する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>同階層n個前 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a424a4503f253da136a3a4217ed7b3562"></a><!-- doxytag: member="sxsdk::shape_class::rbegin" ref="a424a4503f253da136a3a4217ed7b3562" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1reverse__iterator.html">reverse_iterator</a> sxsdk::shape_class::rbegin </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>逆方向のイテレータを返す。 </p>
<p><a class="el" href="structsxsdk_1_1shape__class.html#a40fb84dcfb17b83ca6b1ddb521de0737" title="下位階層の最初の形状のイテレータを取得する。">begin()</a>, <a class="el" href="structsxsdk_1_1shape__class.html#a7a5b031257e482c32cb306a47244bc6d" title="下位階層の最後の形状(番兵形状)のイテレータを取得する。">end()</a>と異なり、ブラウザで見て下の方の子形状から順にたどる。 </p>

</div>
</div>
<a class="anchor" id="a34dbdf209bedd00db32f8d5ee305e6a7"></a><!-- doxytag: member="sxsdk::shape_class::remove_tag" ref="a34dbdf209bedd00db32f8d5ee305e6a7" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::remove_tag </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状に設定されたtagを削除する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a981d9a8453cd5dc8a6d78bb7d980ce29"></a><!-- doxytag: member="sxsdk::shape_class::rend" ref="a981d9a8453cd5dc8a6d78bb7d980ce29" args="(void *aux=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classsxsdk_1_1shape__class_1_1reverse__iterator.html">reverse_iterator</a> sxsdk::shape_class::rend </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>逆方向のイテレータを返す。 </p>
<p><a class="el" href="structsxsdk_1_1shape__class.html#a40fb84dcfb17b83ca6b1ddb521de0737" title="下位階層の最初の形状のイテレータを取得する。">begin()</a>, <a class="el" href="structsxsdk_1_1shape__class.html#a7a5b031257e482c32cb306a47244bc6d" title="下位階層の最後の形状(番兵形状)のイテレータを取得する。">end()</a>と異なり、ブラウザで見て下の方の子形状から順にたどる。 </p>

</div>
</div>
<a class="anchor" id="a4cc25c898d21d4b577adf1f9673c81c4"></a><!-- doxytag: member="sxsdk::shape_class::reset_transformation" ref="a4cc25c898d21d4b577adf1f9673c81c4" args="(bool deep=false, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::reset_transformation </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>deep</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>変換マトリクスをリセットする。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>deep</em>&nbsp;</td><td>trueを渡すと下位階層のすべての形状の変換マトリクスがリセットされる。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33aaa994f0920546c9ec78219e989408"></a><!-- doxytag: member="sxsdk::shape_class::select_all_control_points" ref="a33aaa994f0920546c9ec78219e989408" args="(bool select, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::select_all_control_points </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>全てのコントロールポイントを選択／非選択する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a15be5f50617d9ba38272fb1cd35d1e5f" title="指定したコントロールポイントの選択状態を設定する。">set_active_control_point()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a0c43f1db671eab28283519aa41262dfe" title="指定したコントロールポイントの選択状態を取得する。">get_active_control_point()</a></code> でポイントごとの選択状態を設定、取得ができる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>select</em>&nbsp;</td><td>選択フラグ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15be5f50617d9ba38272fb1cd35d1e5f"></a><!-- doxytag: member="sxsdk::shape_class::set_active_control_point" ref="a15be5f50617d9ba38272fb1cd35d1e5f" args="(int at, bool select, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::set_active_control_point </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>at</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>select</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>指定したコントロールポイントの選択状態を設定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a0c43f1db671eab28283519aa41262dfe" title="指定したコントロールポイントの選択状態を取得する。">get_active_control_point()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#adc1089a61be1db5de27c0ba324c53279" title="選択されているコントロールポイントの番号のリストを取得する。...">get_active_control_points()</a></code> で選択状態を取得できる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>at</em>&nbsp;</td><td>コントロールポイントの番号 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>select</em>&nbsp;</td><td>選択状態フラグ </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac02ee44513cc99bc33ee281562a7a57d"></a><!-- doxytag: member="sxsdk::shape_class::set_axis_matrix" ref="ac02ee44513cc99bc33ee281562a7a57d" args="(const sxsdk::mat4 &amp;to, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::set_axis_matrix </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の軸を定義するマトリクスを設定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a010d4f7ee04996674701c479cc9e8fb3" title="回転体の軸を定義するマトリクスを取得する。">get_axis_matrix()</a></code> で回転体の軸を定義するマトリクスを取得する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。</p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d" title="回転体の開始角度(ラジアン)を設定する。">set_revolve_from()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b" title="回転体の開始角度(ラジアン)を取得する。">get_revolve_from()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e" title="回転体の終了角度(ラジアン)を設定する。">set_revolve_to()</a>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792" title="回転体の終了角度(ラジアン)を取得する。">get_revolve_to()</a></code> で開始角度、終了角度の設定、取得する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>to</em>&nbsp;</td><td>回転体の軸を定義するマトリクス </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeda4393c11d630541b26fbbc9aeef768"></a><!-- doxytag: member="sxsdk::shape_class::set_browsable" ref="aeda4393c11d630541b26fbbc9aeef768" args="(bool browsable_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_browsable </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>browsable_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状がブラウザウインドウに表示可能かどうかを設定する。 </p>
<p>falseが設定されると、ブラウザからは見えない形状になる。 </p>

</div>
</div>
<a class="anchor" id="a74393c305bca1e6b397d9ceff2e52127"></a><!-- doxytag: member="sxsdk::shape_class::set_extrude" ref="a74393c305bca1e6b397d9ceff2e52127" args="(const sxsdk::vec3 &amp;extrude_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_extrude </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>extrude_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>掃引の方向と距離を設定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#aa42b478384b94d85bc3fdc180878387d" title="掃引体かどうかか判定する。">is_extruded()</a></code> で掃引体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="a44a2eb909f4ec9f0294efa201c8fab23"></a><!-- doxytag: member="sxsdk::shape_class::set_master_surface" ref="a44a2eb909f4ec9f0294efa201c8fab23" args="(sxsdk::master_surface_class *master_surface_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_master_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1master__surface__class.html">sxsdk::master_surface_class</a> *&nbsp;</td>
          <td class="paramname"> <em>master_surface_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>マスターサーフェスの適用を設定する。 </p>
<p>マスターサーフェスの形状の<code><a class="el" href="structsxsdk_1_1master__surface__class.html">master_surface_class</a></code> を渡す。0を渡すと適用を解除する。 </p>

</div>
</div>
<a class="anchor" id="a87ebbdb668ba95fcba4f111ab188a7dd"></a><!-- doxytag: member="sxsdk::shape_class::set_modifiable" ref="a87ebbdb668ba95fcba4f111ab188a7dd" args="(bool modifiable_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_modifiable </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>modifiable_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状がモディファイ可能かどうかを設定する。 </p>
<p>falseが設定されると、モディファイモード時にコントロールポイントが表示されなくなる。 </p>

</div>
</div>
<a class="anchor" id="a7afcd59713aa04be787b73667aed96b2"></a><!-- doxytag: member="sxsdk::shape_class::set_name" ref="a7afcd59713aa04be787b73667aed96b2" args="(const char *name_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_name </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状の名前を設定する。 </p>
<p>0を渡すとデフォルト名が設定される。 </p>

</div>
</div>
<a class="anchor" id="ab7ac881abe095d50160bb04d1479bd96"></a><!-- doxytag: member="sxsdk::shape_class::set_related_shape" ref="ab7ac881abe095d50160bb04d1479bd96" args="(const sx::uuid_class &amp;relation_id, sxsdk::shape_class *shape, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::set_related_shape </td>
          <td>(</td>
          <td class="paramtype">const sx::uuid_class &amp;&nbsp;</td>
          <td class="paramname"> <em>relation_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> *&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状と形状を相互に関連付けする。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#aa1530d962009930861be2d9f40a01c3b" title="set_related_shape() で関連付けされた形状のリストを取得する。">get_related_shapes()</a></code> で関連付けした形状を取得、<code><a class="el" href="structsxsdk_1_1shape__class.html#a9173a534713e89cedfbfbc84684b7db4" title="set_related_shape() で設定した関連付けを削除する。">delete_relation()</a></code> で関連付けを削除する。</p>
<p>関連付けされている形状の片方が削除されると、自動的に関連付けも解除される。</p>
<p>関連付けは双方向で行われるので、shapeで渡した形状からも <code><a class="el" href="structsxsdk_1_1shape__class.html#ab7ac881abe095d50160bb04d1479bd96" title="形状と形状を相互に関連付けする。">set_related_shape()</a></code> を呼び出した形状を参照できる。</p>
<p>関連付けの際には親子関係は作られない。</p>
<p>relation_id を代えずに異なる形状を渡すことで、複数の形状との関連付けを設定できる。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>relation_id</em>&nbsp;</td><td>関連付けの種類を識別する<code>uuid</code> (生成方法は<a class="el" href="pluginid.html">プラグインID</a> を参照) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shape</em>&nbsp;</td><td>関連付けを行う形状 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f94347bb8c1a087dc3d0e0188e64402"></a><!-- doxytag: member="sxsdk::shape_class::set_render_flag" ref="a0f94347bb8c1a087dc3d0e0188e64402" args="(int render_flag_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_render_flag </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>render_flag_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>レンダリング対象とするかどうかを設定する。 </p>
<p>-1: 継承（デフォルト）、0: レンダリングしない、1: 常にレンダリング</p>
<p>継承が設定されている場合は上位パートの設定が有効になる。 </p>

</div>
</div>
<a class="anchor" id="a01e78a6f1b15b9e0181c2e3bfa86d4bf"></a><!-- doxytag: member="sxsdk::shape_class::set_rendering" ref="a01e78a6f1b15b9e0181c2e3bfa86d4bf" args="(int rendering_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_rendering </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>rendering_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>レンダリングの対象となるかどうかを設定する。 </p>
<p>-1: 継承, 0: レンダリングしない, 1: 常にレンダリング。</p>
<p>リンクから参照されている場合もあるため、形状を指定しただけでは実際にその形状がレンダリングの対象となるかどうかは判定できない。rendering属性は単純に３値のフラグで、その値が-1の場合には、実際にどういう経路で（リンクを介して）継承されるのかはプラグイン自身で判定する必要がある。</p>
<p>レンダリング中であれば、<code><a class="el" href="structsxsdk_1_1rendering__context__interface.html#adab29b0b1b7f3855c0b26508fceec02c" title="形状がレンダリングの対象となっているかどうかを返す。">rendering_context_interface::get_rendering_flag()</a></code> でレンダリング対象かどうかを判定できる。 </p>

</div>
</div>
<a class="anchor" id="a3ae19dcf3327e1e1bed5ca02b59eb07d"></a><!-- doxytag: member="sxsdk::shape_class::set_revolve_from" ref="a3ae19dcf3327e1e1bed5ca02b59eb07d" args="(float revolve_from_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_revolve_from </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>revolve_from_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の開始角度(ラジアン)を設定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#accef93bfb10d51f2e25f013055fc9f4e" title="回転体の終了角度(ラジアン)を設定する。">set_revolve_to()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#a9ec29179a5703dc9140a835855714792" title="回転体の終了角度(ラジアン)を取得する。">get_revolve_to()</a> で終了角度を設定、取得する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="accef93bfb10d51f2e25f013055fc9f4e"></a><!-- doxytag: member="sxsdk::shape_class::set_revolve_to" ref="accef93bfb10d51f2e25f013055fc9f4e" args="(float revolve_to_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_revolve_to </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>revolve_to_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体の終了角度(ラジアン)を設定する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a3ae19dcf3327e1e1bed5ca02b59eb07d" title="回転体の開始角度(ラジアン)を設定する。">set_revolve_from()</a></code>, <a class="el" href="structsxsdk_1_1shape__class.html#ae019a1a3be32d6615f4c4f5e71a01b1b" title="回転体の開始角度(ラジアン)を取得する。">get_revolve_from()</a> で開始角度を設定、取得する。<code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="a347530416943ef1ac855f0f87ac715c4"></a><!-- doxytag: member="sxsdk::shape_class::set_shadow_catcher" ref="a347530416943ef1ac855f0f87ac715c4" args="(int shadow_catcher_param, void *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structsxsdk_1_1shape__class.html">shape_class</a>&amp; sxsdk::shape_class::set_shadow_catcher </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>shadow_catcher_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>シャドウキャッチャーを設定する。 </p>
<p>-1: 継承, 0: レンダリングする, 1: 影のみをレンダリング。 </p>

</div>
</div>
<a class="anchor" id="a89bfca3a6363939b53ee036561d064e8"></a><!-- doxytag: member="sxsdk::shape_class::set_surface" ref="a89bfca3a6363939b53ee036561d064e8" args="(surface_interface *surface, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::set_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><code><a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a></code> から表面材質を適用する。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>surface</em>&nbsp;</td><td>適用する表面材質の<code><a class="el" href="structsxsdk_1_1surface__interface.html">surface_interface</a></code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1ab4b5d0b80a698701133c3259bd843f"></a><!-- doxytag: member="sxsdk::shape_class::set_tag_boolValue" ref="a1ab4b5d0b80a698701133c3259bd843f" args="(const char *tagName, bool value, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::set_tag_boolValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして値を形状にセットする </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d980750ce02d382aed43aa375cffbb9"></a><!-- doxytag: member="sxsdk::shape_class::set_tag_doubleValue" ref="a0d980750ce02d382aed43aa375cffbb9" args="(const char *tagName, double value, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::set_tag_doubleValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして値を形状にセットする </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7acdc7fe6e5744c1c4059ccd590a661"></a><!-- doxytag: member="sxsdk::shape_class::set_tag_floatValue" ref="ad7acdc7fe6e5744c1c4059ccd590a661" args="(const char *tagName, float value, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::set_tag_floatValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして値を形状にセットする </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5bbca8931055f404c497ef63de28bc1d"></a><!-- doxytag: member="sxsdk::shape_class::set_tag_intValue" ref="a5bbca8931055f404c497ef63de28bc1d" args="(const char *tagName, int value, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::set_tag_intValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして値を形状にセットする </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c13dc28bd9519d90812e7602f82f0cf"></a><!-- doxytag: member="sxsdk::shape_class::set_tag_stringValue" ref="a1c13dc28bd9519d90812e7602f82f0cf" args="(const char *tagName, const char *value, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sxsdk::shape_class::set_tag_stringValue </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとして値を形状にセットする </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>値 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86eb2f9b77ea5dcf307451c87d594be7"></a><!-- doxytag: member="sxsdk::shape_class::show" ref="a86eb2f9b77ea5dcf307451c87d594be7" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::show </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状を表示する。 </p>
<p>図形メニューから「表示（選択形状）」を選択したときと同じ動作をする。 </p>

</div>
</div>
<a class="anchor" id="aad9db70faddfb7956a8a88b6101b314c"></a><!-- doxytag: member="sxsdk::shape_class::solid_clear" ref="aad9db70faddfb7956a8a88b6101b314c" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::solid_clear </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>掃引体、回転体を通常の形状に復帰する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#aa42b478384b94d85bc3fdc180878387d" title="掃引体かどうかか判定する。">is_extruded()</a></code>, <code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で掃引体、回転体かどうかを取得する。 </p>

</div>
</div>
<a class="anchor" id="ad0de7cd623ba32641ccee2c29041f37b"></a><!-- doxytag: member="sxsdk::shape_class::solid_extrude" ref="ad0de7cd623ba32641ccee2c29041f37b" args="(const sxsdk::vec3 &amp;by, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::solid_extrude </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>掃引体を作成する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#aa42b478384b94d85bc3fdc180878387d" title="掃引体かどうかか判定する。">is_extruded()</a></code> で掃引体かどうかを取得する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>by</em>&nbsp;</td><td>掃引ベクトル </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2865369d7be91398c7897c1d43bbb4ac"></a><!-- doxytag: member="sxsdk::shape_class::solid_revolve" ref="a2865369d7be91398c7897c1d43bbb4ac" args="(const sxsdk::vec3 &amp;v0, const sxsdk::vec3 &amp;v1, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::solid_revolve </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>回転体を作成する。 </p>
<p><code><a class="el" href="structsxsdk_1_1shape__class.html#a5efe1dfae7d7d5e55c70c1e9ea0f95d2" title="回転体かどうかか判定する。">is_revolved()</a></code> で回転体かどうかを取得する。</p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>v0</em>&nbsp;</td><td>回転軸の始点 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v1</em>&nbsp;</td><td>回転軸の終点 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9b43c1d541848773875dd86d1d525c6"></a><!-- doxytag: member="sxsdk::shape_class::tag_value_type" ref="ab9b43c1d541848773875dd86d1d525c6" args="(const char *tagName, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sxsdk::shape_class::tag_value_type </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>tagName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tag名称をキーとしてセットした値を種類を取得する </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tagName</em>&nbsp;</td><td>tag名称 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f6ddd02a66777a27253dfebf2be2893"></a><!-- doxytag: member="sxsdk::shape_class::transform" ref="a6f6ddd02a66777a27253dfebf2be2893" args="(const sxsdk::mat4 &amp;matrix, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::shape_class::transform </td>
          <td>(</td>
          <td class="paramtype">const sxsdk::mat4 &amp;&nbsp;</td>
          <td class="paramname"> <em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>形状にマトリクス変換をかける。 </p>
<dl><dt><b>引数:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrix</em>&nbsp;</td><td>変換マトリクス </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>この構造体の説明は次のファイルから生成されました:<ul>
<li><a class="el" href="shapeclass_8h_source.html">shapeclass.h</a></li>
</ul>
</div>
<br><br>
<hr>
<div align="center">Copyright &copy; e frontier, Inc. All rights reserved.</div>
</body></html>
