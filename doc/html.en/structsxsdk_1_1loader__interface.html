<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>sxsdk::loader_interface Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespacesxsdk.html">sxsdk</a>::<a class="el" href="structsxsdk_1_1loader__interface.html">loader_interface</a>
  </div>
</div>
<div class="contents">
<h1>sxsdk::loader_interface Struct Reference</h1><!-- doxytag: class="sxsdk::loader_interface" --><!-- doxytag: inherits="unknown_interface" --><div class="dynheader">
Inheritance diagram for sxsdk::loader_interface:</div>
<div class="dynsection">
 <div class="center">
  <img src="structsxsdk_1_1loader__interface.gif" usemap="#sxsdk::loader_interface_map" alt=""/>
  <map id="sxsdk::loader_interface_map" name="sxsdk::loader_interface_map">
<area href="classunknown__interface.html" alt="unknown_interface" shape="rect" coords="0,0,142,24"/>
</map>
 </div>
</div>

<p><a href="structsxsdk_1_1loader__interface-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a78f1763c8487425fe7ba63a2af44b33a">do_load</a> (<a class="el" href="structsxsdk_1_1loader__info__interface.html">sxsdk::loader_info_interface</a> *loader_info, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the beginning of the load operation.  <a href="#a78f1763c8487425fe7ba63a2af44b33a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a821d36e0e2dcf17b66d913c271f977e0"></a><!-- doxytag: member="sxsdk::loader_interface::skip_load_objects" ref="a821d36e0e2dcf17b66d913c271f977e0" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a821d36e0e2dcf17b66d913c271f977e0">skip_load_objects</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6441c21eb60b90c9361efb959ddfe982"></a><!-- doxytag: member="sxsdk::loader_interface::start" ref="a6441c21eb60b90c9361efb959ddfe982" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a6441c21eb60b90c9361efb959ddfe982">start</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the beginning of the load operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0faf6855f49ca5f7a324a8ede8962a12"></a><!-- doxytag: member="sxsdk::loader_interface::finish" ref="a0faf6855f49ca5f7a324a8ede8962a12" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a0faf6855f49ca5f7a324a8ede8962a12">finish</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the end of the load operation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6df2ac97d580de4576b2e8e5745e309b"></a><!-- doxytag: member="sxsdk::loader_interface::begin" ref="a6df2ac97d580de4576b2e8e5745e309b" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a6df2ac97d580de4576b2e8e5745e309b">begin</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the start of the current object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8724f0dcb4bb5b9af0054820b044c803"></a><!-- doxytag: member="sxsdk::loader_interface::end" ref="a8724f0dcb4bb5b9af0054820b044c803" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a8724f0dcb4bb5b9af0054820b044c803">end</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the end of the current object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4188ecba4ede52bf2e401c34ca33826b"></a><!-- doxytag: member="sxsdk::loader_interface::head" ref="a4188ecba4ede52bf2e401c34ca33826b" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a4188ecba4ede52bf2e401c34ca33826b">head</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the start of the current node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a991605c57c591b17cf4977932f16ba"></a><!-- doxytag: member="sxsdk::loader_interface::tail" ref="a4a991605c57c591b17cf4977932f16ba" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a4a991605c57c591b17cf4977932f16ba">tail</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called at the end of the current node. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0e6ee4b79c9560ce7c533919e83dec"></a><!-- doxytag: member="sxsdk::loader_interface::must_skip" ref="acd0e6ee4b79c9560ce7c533919e83dec" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#acd0e6ee4b79c9560ce7c533919e83dec">must_skip</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a61c3d57d0734a43eb237764af7ec0d95">set_transformation</a> (const sx::mat&lt; float, 4 &gt; &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. When the current object is the top portion of an extruded object, the transformation matrix that represents the extrusion is passed as the parameter.  <a href="#a61c3d57d0734a43eb237764af7ec0d95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a119c3ae53ece8c5432b44855f784a207"></a><!-- doxytag: member="sxsdk::loader_interface::clear_transformation" ref="a119c3ae53ece8c5432b44855f784a207" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a119c3ae53ece8c5432b44855f784a207">clear_transformation</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called after the top portion of an extruded object has been processed to give plugin a chance to clear the transformation matrix that has been passed by the previous set_transformation call. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a957a760f67046859bfb52e9894c67338"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_polyline" ref="a957a760f67046859bfb52e9894c67338" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a957a760f67046859bfb52e9894c67338">can_accept_polyline</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle open line objects (<code><a class="el" href="structsxsdk_1_1loader__interface.html#a211c91e222741851d7d50064fc754489" title="Overridable. Called when the current object is an open line object. Called only if...">do_polyline()</a></code> is called). <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a545ed74c2b9b1ac702660dc8c6789408"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_polygon" ref="a545ed74c2b9b1ac702660dc8c6789408" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a545ed74c2b9b1ac702660dc8c6789408">can_accept_polygon</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle closed line objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a04aa421a1cabe7776412a06635994fe6">can_accept_sphere</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle sphere objects.  <a href="#a04aa421a1cabe7776412a06635994fe6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ac1391f6cf105489ee049bf278b1c95e9">can_accept_bezier_surface</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle curved surface objects.  <a href="#ac1391f6cf105489ee049bf278b1c95e9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a23ebdf0226319e7564b4375e721d3ec5">can_accept_polymesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle polygon mesh objects.  <a href="#a23ebdf0226319e7564b4375e721d3ec5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01f178b9aecfe1889d6cd6beaa4dd885"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_disk" ref="a01f178b9aecfe1889d6cd6beaa4dd885" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a01f178b9aecfe1889d6cd6beaa4dd885">can_accept_disk</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle disk objects. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1af2fdac30577ca4b062dd7a878b965"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_closed_mesh" ref="ac1af2fdac30577ca4b062dd7a878b965" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ac1af2fdac30577ca4b062dd7a878b965">can_accept_closed_mesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if waiting for a closed polygon mesh. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ab2d75e5ebafb33cd759fa7019526f317">can_accept_meshes</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. If override and return false, the plugins avoid calling do_meshes to process by polygonmesh.  <a href="#ab2d75e5ebafb33cd759fa7019526f317"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a94a38f83c51e72bec0203215841d7c73">can_accept_link</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle link objects.  <a href="#a94a38f83c51e72bec0203215841d7c73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a815ec6981bb7e27a1a4cff94cfb488e8"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_linear_light" ref="a815ec6981bb7e27a1a4cff94cfb488e8" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a815ec6981bb7e27a1a4cff94cfb488e8">can_accept_linear_light</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3e941faac3e3cfa4e20ce3ca1fc99a56"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_area_light" ref="a3e941faac3e3cfa4e20ce3ca1fc99a56" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a3e941faac3e3cfa4e20ce3ca1fc99a56">can_accept_area_light</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af9ebd0a3047abad559845a07d0739f70"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_light" ref="af9ebd0a3047abad559845a07d0739f70" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#af9ebd0a3047abad559845a07d0739f70">can_accept_light</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ae53b0b7842019ca55d2bab0d4ecf7496">can_accept_replicator</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah.  <a href="#ae53b0b7842019ca55d2bab0d4ecf7496"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a7eb69a6743eb8f5d7cfe3160b837f838">can_accept_switch</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle switch joints.  <a href="#a7eb69a6743eb8f5d7cfe3160b837f838"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a5c3ebd53a4c1ebc0b6224abceca96b11">must_triangulate_polymesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Faces of polygon mesh objects will be triangulated if this function returns true.  <a href="#a5c3ebd53a4c1ebc0b6224abceca96b11"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5fb78fa13e93f441c1671f6187a1296c"></a><!-- doxytag: member="sxsdk::loader_interface::must_divide_polymesh" ref="a5fb78fa13e93f441c1671f6187a1296c" args="(void *aux=0)" -->
virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a5fb78fa13e93f441c1671f6187a1296c">must_divide_polymesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Faces of polygon mesh objects will be divided if this function returns true. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a434eb0591992ac24d73728e04ac32166">get_max_vertices_per_face</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return the maximum number of vertices per polygon mesh face that the plugin can handle. 3, 4 and -1 are valid, and -1 means no limit.  <a href="#a434eb0591992ac24d73728e04ac32166"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a211c91e222741851d7d50064fc754489">do_polyline</a> (<a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *points, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is an open line object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a957a760f67046859bfb52e9894c67338" title="Overridable. Override and return true if the plugin can handle open line objects...">can_accept_polyline()</a> function returns true.  <a href="#a211c91e222741851d7d50064fc754489"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a28b940cd7fd64b01fc5feb41a13a0937">do_polygon</a> (int n, <a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> **c, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is an open line object, or an object of another type has been converted to a closed polygon. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a545ed74c2b9b1ac702660dc8c6789408" title="Overridable. Override and return true if the plugin can handle closed line objects...">can_accept_polygon()</a> function returns true.  <a href="#a28b940cd7fd64b01fc5feb41a13a0937"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a427bdaf016fa0c24d14253cdd0ec45f9">do_meshes</a> (<a class="el" href="structsxsdk_1_1meshes__interface.html">sxsdk::meshes_interface</a> *m, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is converted to a meshes object.  <a href="#a427bdaf016fa0c24d14253cdd0ec45f9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ae40cc89a89cab872eaa1a70cde10661c">do_sphere</a> (const sx::mat&lt; float, 4 &gt; &amp;t, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a sphere object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a04aa421a1cabe7776412a06635994fe6" title="Overridable. Override and return true if the plugin can handle sphere objects.">can_accept_sphere()</a> function returns true.  <a href="#ae40cc89a89cab872eaa1a70cde10661c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a3260018122173fbee2a040269b0c76c5">do_disk</a> (const sx::mat&lt; float, 4 &gt; &amp;t, float t0, float t1, bool filled, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a disk. Only called when <code><a class="el" href="structsxsdk_1_1loader__interface.html#a01f178b9aecfe1889d6cd6beaa4dd885" title="Overridable. Override and return true if the plugin can handle disk objects.">can_accept_disk()</a></code> returns true.  <a href="#a3260018122173fbee2a040269b0c76c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a40964ea896d79dde78439e29c11f6586">do_bezier_surface</a> (<a class="el" href="structsxsdk_1_1mesh__interface.html">sxsdk::mesh_interface</a> *m, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a curved surface object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#ac1391f6cf105489ee049bf278b1c95e9" title="Overridable. Override and return true if the plugin can handle curved surface objects...">can_accept_bezier_surface()</a> function returns true.  <a href="#a40964ea896d79dde78439e29c11f6586"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed5c97a5971b559741b3fb4bb0e1372a"></a><!-- doxytag: member="sxsdk::loader_interface::begin_polymesh" ref="aed5c97a5971b559741b3fb4bb0e1372a" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#aed5c97a5971b559741b3fb4bb0e1372a">begin_polymesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a polygon mesh object, or an object of another type has been converted to the polygon mesh object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ae05817501bb62de907bd4676d896cfae">begin_polymesh_vertex</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called to indicate the beginning of the vertices after <a class="el" href="structsxsdk_1_1loader__interface.html#aed5c97a5971b559741b3fb4bb0e1372a" title="Overridable. Called when the current object is a polygon mesh object, or an object...">begin_polymesh()</a> has been called.  <a href="#ae05817501bb62de907bd4676d896cfae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ac6c9b769179ce4c6d83b6338fec39cd5">polymesh_vertex</a> (int i, const sxsdk::vec3 &amp;v, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called for each vertex of the polygon mesh object.  <a href="#ac6c9b769179ce4c6d83b6338fec39cd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e633af210e06778bc0951c63d8dad7a"></a><!-- doxytag: member="sxsdk::loader_interface::end_polymesh_vertex" ref="a2e633af210e06778bc0951c63d8dad7a" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a2e633af210e06778bc0951c63d8dad7a">end_polymesh_vertex</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called to indicate the end of the vertices. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a571f3cf06233a0548524fccbff60b99d">begin_polymesh_face</a> (int n, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called to indicate the beginning of a sequence of faces.  <a href="#a571f3cf06233a0548524fccbff60b99d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a5daaa56a03535e41a8904b52c7c08dc7">polymesh_face</a> (int n_list, const int list[], const sxsdk::vec3 *normals, const sxsdk::vec4 *plane_equation, const sxsdk::vec4 *uvs, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Infomation on a polygon mesh face alog with its vertices uv parameters are passed to the plugin.  <a href="#a5daaa56a03535e41a8904b52c7c08dc7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab80b8d1c6f7433d858fb1656226fe940"></a><!-- doxytag: member="sxsdk::loader_interface::end_polymesh_face" ref="ab80b8d1c6f7433d858fb1656226fe940" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ab80b8d1c6f7433d858fb1656226fe940">end_polymesh_face</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called to indicate the end of a sequence of faces. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a557bebed2bb900179e31064fc38147b1"></a><!-- doxytag: member="sxsdk::loader_interface::end_polymesh" ref="a557bebed2bb900179e31064fc38147b1" args="(void *aux=0)" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a557bebed2bb900179e31064fc38147b1">end_polymesh</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called to indicate the end of processing of the polygon mesh object. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a0196c0e67bcbd5cb27432a035895d8d3">do_link</a> (<a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;link, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a link object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a94a38f83c51e72bec0203215841d7c73" title="Overridable. Override and return true if the plugin can handle link objects.">can_accept_link()</a> function returns true.  <a href="#a0196c0e67bcbd5cb27432a035895d8d3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a60ac808915b438d639718f95ed1ecb29">do_linear_light</a> (<a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *points, bool closed, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah.  <a href="#a60ac808915b438d639718f95ed1ecb29"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ae9af3fd8ab67ddecf03cf9f4fda82072">do_area_light</a> (<a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *points, float area, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah.  <a href="#ae9af3fd8ab67ddecf03cf9f4fda82072"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#ad2637f8f7ad443d6d80a5d4113cfd44c">do_light</a> (<a class="el" href="namespacesxsdk_1_1enums.html#a3797db46b7674c36747f0802b39e87d7">sxsdk::enums::light_distribution_type</a> points, const sxsdk::vec3 *color, const sxsdk::vec3 *position, const sxsdk::vec3 *direction, float angle, float softness, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah.  <a href="#ad2637f8f7ad443d6d80a5d4113cfd44c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#afd44d7639e1b5f16924170604570ad96">do_replicator</a> (<a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;replicator, <a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;shape, const sxsdk::mat4 *trans, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. blah.  <a href="#afd44d7639e1b5f16924170604570ad96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#afbe4ef394035f66a1111c66f6191a59f">do_switch</a> (<a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;switch_joint, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a switch joint. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a7eb69a6743eb8f5d7cfe3160b837f838" title="Overridable. Override and return true if the plugin can handle switch joints.">can_accept_switch()</a> function returns true.  <a href="#afbe4ef394035f66a1111c66f6191a59f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a28717652dbc6da3b2c5336f7b0d94a0a">can_accept_mirror</a> (void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Override and return true if the plugin can handle mirror objects.  <a href="#a28717652dbc6da3b2c5336f7b0d94a0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsxsdk_1_1loader__interface.html#a3ae54718e7952680d59746debdf91be9">do_mirror</a> (<a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;shape, void *aux=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Overridable. Called when the current object is a mirror object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a28717652dbc6da3b2c5336f7b0d94a0a" title="Overridable. Override and return true if the plugin can handle mirror objects.">can_accept_mirror()</a> function returns true.  <a href="#a3ae54718e7952680d59746debdf91be9"></a><br/></td></tr>
</table>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a571f3cf06233a0548524fccbff60b99d"></a><!-- doxytag: member="sxsdk::loader_interface::begin_polymesh_face" ref="a571f3cf06233a0548524fccbff60b99d" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::begin_polymesh_face </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called to indicate the beginning of a sequence of faces. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>the number of faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae05817501bb62de907bd4676d896cfae"></a><!-- doxytag: member="sxsdk::loader_interface::begin_polymesh_vertex" ref="ae05817501bb62de907bd4676d896cfae" args="(int n, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::begin_polymesh_vertex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called to indicate the beginning of the vertices after <a class="el" href="structsxsdk_1_1loader__interface.html#aed5c97a5971b559741b3fb4bb0e1372a" title="Overridable. Called when the current object is a polygon mesh object, or an object...">begin_polymesh()</a> has been called. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>the number of vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1391f6cf105489ee049bf278b1c95e9"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_bezier_surface" ref="ac1391f6cf105489ee049bf278b1c95e9" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_bezier_surface </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle curved surface objects. </p>
<p>Converts to a polygon mesh if false is returned. </p>

</div>
</div>
<a class="anchor" id="a94a38f83c51e72bec0203215841d7c73"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_link" ref="a94a38f83c51e72bec0203215841d7c73" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_link </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle link objects. </p>
<p>If false is returned, make the link objects real objects and call the callback functions like <code><a class="el" href="structsxsdk_1_1loader__interface.html#ae40cc89a89cab872eaa1a70cde10661c" title="Overridable. Called when the current object is a sphere object. Called only if the...">do_sphere()</a></code> and <code><a class="el" href="structsxsdk_1_1loader__interface.html#a28b940cd7fd64b01fc5feb41a13a0937" title="Overridable. Called when the current object is an open line object, or an object...">do_polygon()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ab2d75e5ebafb33cd759fa7019526f317"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_meshes" ref="ab2d75e5ebafb33cd759fa7019526f317" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_meshes </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. If override and return false, the plugins avoid calling do_meshes to process by polygonmesh. </p>
<p>Call do_meshes if true is returned. </p>

</div>
</div>
<a class="anchor" id="a28717652dbc6da3b2c5336f7b0d94a0a"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_mirror" ref="a28717652dbc6da3b2c5336f7b0d94a0a" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_mirror </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle mirror objects. </p>
<p>If false is returned, make the mirror objects real objects and call the callback functions like <code><a class="el" href="structsxsdk_1_1loader__interface.html#a28b940cd7fd64b01fc5feb41a13a0937" title="Overridable. Called when the current object is an open line object, or an object...">do_polygon()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a23ebdf0226319e7564b4375e721d3ec5"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_polymesh" ref="a23ebdf0226319e7564b4375e721d3ec5" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_polymesh </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle polygon mesh objects. </p>
<p>If false is returned all the faces of the polygon mesh are passed to <code><a class="el" href="structsxsdk_1_1loader__interface.html#a28b940cd7fd64b01fc5feb41a13a0937" title="Overridable. Called when the current object is an open line object, or an object...">do_polygon()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ae53b0b7842019ca55d2bab0d4ecf7496"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_replicator" ref="ae53b0b7842019ca55d2bab0d4ecf7496" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_replicator </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. blah. </p>
<p>blah. </p>

</div>
</div>
<a class="anchor" id="a04aa421a1cabe7776412a06635994fe6"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_sphere" ref="a04aa421a1cabe7776412a06635994fe6" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_sphere </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle sphere objects. </p>
<p>Converts to a polygon mesh if false is returned. </p>

</div>
</div>
<a class="anchor" id="a7eb69a6743eb8f5d7cfe3160b837f838"></a><!-- doxytag: member="sxsdk::loader_interface::can_accept_switch" ref="a7eb69a6743eb8f5d7cfe3160b837f838" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::can_accept_switch </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return true if the plugin can handle switch joints. </p>
<p>blah. </p>

</div>
</div>
<a class="anchor" id="ae9af3fd8ab67ddecf03cf9f4fda82072"></a><!-- doxytag: member="sxsdk::loader_interface::do_area_light" ref="ae9af3fd8ab67ddecf03cf9f4fda82072" args="(sxsdk::points_interface *points, float area, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_area_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. blah. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>the points of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area</em>&nbsp;</td><td>blah </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40964ea896d79dde78439e29c11f6586"></a><!-- doxytag: member="sxsdk::loader_interface::do_bezier_surface" ref="a40964ea896d79dde78439e29c11f6586" args="(sxsdk::mesh_interface *m, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_bezier_surface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1mesh__interface.html">sxsdk::mesh_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a curved surface object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#ac1391f6cf105489ee049bf278b1c95e9" title="Overridable. Override and return true if the plugin can handle curved surface objects...">can_accept_bezier_surface()</a> function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>the mesh of definition points of the curved surface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3260018122173fbee2a040269b0c76c5"></a><!-- doxytag: member="sxsdk::loader_interface::do_disk" ref="a3260018122173fbee2a040269b0c76c5" args="(const sx::mat&lt; float, 4 &gt; &amp;t, float t0, float t1, bool filled, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_disk </td>
          <td>(</td>
          <td class="paramtype">const sx::mat&lt; float, 4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>t0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>filled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a disk. Only called when <code><a class="el" href="structsxsdk_1_1loader__interface.html#a01f178b9aecfe1889d6cd6beaa4dd885" title="Overridable. Override and return true if the plugin can handle disk objects.">can_accept_disk()</a></code> returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>the disk-defining transformation matrix </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t0</em>&nbsp;</td><td>the starting angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>t1</em>&nbsp;</td><td>the ending angle </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filled</em>&nbsp;</td><td>whether or not the center is filled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2637f8f7ad443d6d80a5d4113cfd44c"></a><!-- doxytag: member="sxsdk::loader_interface::do_light" ref="ad2637f8f7ad443d6d80a5d4113cfd44c" args="(sxsdk::enums::light_distribution_type points, const sxsdk::vec3 *color, const sxsdk::vec3 *position, const sxsdk::vec3 *direction, float angle, float softness, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesxsdk_1_1enums.html#a3797db46b7674c36747f0802b39e87d7">sxsdk::enums::light_distribution_type</a>&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>softness</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. blah. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>the points of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>color</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>position</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>direction</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>softness</em>&nbsp;</td><td>blah </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60ac808915b438d639718f95ed1ecb29"></a><!-- doxytag: member="sxsdk::loader_interface::do_linear_light" ref="a60ac808915b438d639718f95ed1ecb29" args="(sxsdk::points_interface *points, bool closed, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_linear_light </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. blah. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>the points of the line </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>closed</em>&nbsp;</td><td>blah </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0196c0e67bcbd5cb27432a035895d8d3"></a><!-- doxytag: member="sxsdk::loader_interface::do_link" ref="a0196c0e67bcbd5cb27432a035895d8d3" args="(sxsdk::part_class &amp;link, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_link </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>link</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a link object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a94a38f83c51e72bec0203215841d7c73" title="Overridable. Override and return true if the plugin can handle link objects.">can_accept_link()</a> function returns true. </p>
<p>Used if exporting to a format supporting link objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>link</em>&nbsp;</td><td>The link object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78f1763c8487425fe7ba63a2af44b33a"></a><!-- doxytag: member="sxsdk::loader_interface::do_load" ref="a78f1763c8487425fe7ba63a2af44b33a" args="(sxsdk::loader_info_interface *loader_info, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1loader__info__interface.html">sxsdk::loader_info_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>loader_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called at the beginning of the load operation. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>loader_info</em>&nbsp;</td><td>Pointer to <code>speed_loader_info_interface</code>. The member functions for getting the xxx_interface of all the objects needed for the load are defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a427bdaf016fa0c24d14253cdd0ec45f9"></a><!-- doxytag: member="sxsdk::loader_interface::do_meshes" ref="a427bdaf016fa0c24d14253cdd0ec45f9" args="(sxsdk::meshes_interface *m, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_meshes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1meshes__interface.html">sxsdk::meshes_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is converted to a meshes object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>m</em>&nbsp;</td><td>the mesh data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ae54718e7952680d59746debdf91be9"></a><!-- doxytag: member="sxsdk::loader_interface::do_mirror" ref="a3ae54718e7952680d59746debdf91be9" args="(sxsdk::shape_class &amp;shape, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_mirror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a mirror object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a28717652dbc6da3b2c5336f7b0d94a0a" title="Overridable. Override and return true if the plugin can handle mirror objects.">can_accept_mirror()</a> function returns true. </p>
<p>Used if exporting to a format supporting mirror objects.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>shape</em>&nbsp;</td><td>The mirror object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28b940cd7fd64b01fc5feb41a13a0937"></a><!-- doxytag: member="sxsdk::loader_interface::do_polygon" ref="a28b940cd7fd64b01fc5feb41a13a0937" args="(int n, sxsdk::points_interface **c, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_polygon </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> **&nbsp;</td>
          <td class="paramname"> <em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is an open line object, or an object of another type has been converted to a closed polygon. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a545ed74c2b9b1ac702660dc8c6789408" title="Overridable. Override and return true if the plugin can handle closed line objects...">can_accept_polygon()</a> function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>the number of polygons </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c</em>&nbsp;</td><td>the array of points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a211c91e222741851d7d50064fc754489"></a><!-- doxytag: member="sxsdk::loader_interface::do_polyline" ref="a211c91e222741851d7d50064fc754489" args="(sxsdk::points_interface *points, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_polyline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1points__interface.html">sxsdk::points_interface</a> *&nbsp;</td>
          <td class="paramname"> <em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is an open line object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a957a760f67046859bfb52e9894c67338" title="Overridable. Override and return true if the plugin can handle open line objects...">can_accept_polyline()</a> function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>points</em>&nbsp;</td><td>the points of the line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd44d7639e1b5f16924170604570ad96"></a><!-- doxytag: member="sxsdk::loader_interface::do_replicator" ref="afd44d7639e1b5f16924170604570ad96" args="(sxsdk::part_class &amp;replicator, sxsdk::shape_class &amp;shape, const sxsdk::mat4 *trans, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_replicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>replicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1shape__class.html">sxsdk::shape_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::mat4 *&nbsp;</td>
          <td class="paramname"> <em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. blah. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>replicator</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>shape</em>&nbsp;</td><td>blah </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trans</em>&nbsp;</td><td>blah. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae40cc89a89cab872eaa1a70cde10661c"></a><!-- doxytag: member="sxsdk::loader_interface::do_sphere" ref="ae40cc89a89cab872eaa1a70cde10661c" args="(const sx::mat&lt; float, 4 &gt; &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_sphere </td>
          <td>(</td>
          <td class="paramtype">const sx::mat&lt; float, 4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a sphere object. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a04aa421a1cabe7776412a06635994fe6" title="Overridable. Override and return true if the plugin can handle sphere objects.">can_accept_sphere()</a> function returns true. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>the sphere-defining matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbe4ef394035f66a1111c66f6191a59f"></a><!-- doxytag: member="sxsdk::loader_interface::do_switch" ref="afbe4ef394035f66a1111c66f6191a59f" args="(sxsdk::part_class &amp;switch_joint, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::do_switch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsxsdk_1_1part__class.html">sxsdk::part_class</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>switch_joint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called when the current object is a switch joint. Called only if the <a class="el" href="structsxsdk_1_1loader__interface.html#a7eb69a6743eb8f5d7cfe3160b837f838" title="Overridable. Override and return true if the plugin can handle switch joints.">can_accept_switch()</a> function returns true. </p>
<p>blah.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>switch_joint</em>&nbsp;</td><td>The switch joint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a434eb0591992ac24d73728e04ac32166"></a><!-- doxytag: member="sxsdk::loader_interface::get_max_vertices_per_face" ref="a434eb0591992ac24d73728e04ac32166" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int sxsdk::loader_interface::get_max_vertices_per_face </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Override and return the maximum number of vertices per polygon mesh face that the plugin can handle. 3, 4 and -1 are valid, and -1 means no limit. </p>
<p>Only valid if <code><a class="el" href="structsxsdk_1_1loader__interface.html#a5c3ebd53a4c1ebc0b6224abceca96b11" title="Overridable. Faces of polygon mesh objects will be triangulated if this function...">must_triangulate_polymesh()</a></code> returns false. </p>

</div>
</div>
<a class="anchor" id="a5c3ebd53a4c1ebc0b6224abceca96b11"></a><!-- doxytag: member="sxsdk::loader_interface::must_triangulate_polymesh" ref="a5c3ebd53a4c1ebc0b6224abceca96b11" args="(void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool sxsdk::loader_interface::must_triangulate_polymesh </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Faces of polygon mesh objects will be triangulated if this function returns true. </p>
<p>If false is returned, the polygon will be divided into the number of vertices set with <code><a class="el" href="structsxsdk_1_1loader__interface.html#a434eb0591992ac24d73728e04ac32166" title="Overridable. Override and return the maximum number of vertices per polygon mesh...">get_max_vertices_per_face()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a5daaa56a03535e41a8904b52c7c08dc7"></a><!-- doxytag: member="sxsdk::loader_interface::polymesh_face" ref="a5daaa56a03535e41a8904b52c7c08dc7" args="(int n_list, const int list[], const sxsdk::vec3 *normals, const sxsdk::vec4 *plane_equation, const sxsdk::vec4 *uvs, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::polymesh_face </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>n_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>list</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 *&nbsp;</td>
          <td class="paramname"> <em>normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec4 *&nbsp;</td>
          <td class="paramname"> <em>plane_equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec4 *&nbsp;</td>
          <td class="paramname"> <em>uvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Infomation on a polygon mesh face alog with its vertices uv parameters are passed to the plugin. </p>
<p>The parameters and distance correction UV values are passed. If the UV values are not needed, use <code><a class="el" href="structsxsdk_1_1loader__interface.html#a5daaa56a03535e41a8904b52c7c08dc7" title="Overridable. Infomation on a polygon mesh face alog with its vertices uv parameters...">polymesh_face()</a></code>. If only the parameter's UV values are needed, use <code>polymesh_face_uvuv()</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>list</em>&nbsp;</td><td>The array of vertex numbers of the face. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>normals</em>&nbsp;</td><td>The array of normals. Only valid when the polygon mesh has Smooth turned on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>plane_equation</em>&nbsp;</td><td>The plane equation parameters. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>uvs</em>&nbsp;</td><td>The array of parameter UV values and distance correction UV values. In <code>vec4</code> with 4 values, values 1 and 2 are parameter UV, and values 3 and 4 are distance correction UV values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6c9b769179ce4c6d83b6338fec39cd5"></a><!-- doxytag: member="sxsdk::loader_interface::polymesh_vertex" ref="ac6c9b769179ce4c6d83b6338fec39cd5" args="(int i, const sxsdk::vec3 &amp;v, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::polymesh_vertex </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sxsdk::vec3 &amp;&nbsp;</td>
          <td class="paramname"> <em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. Called for each vertex of the polygon mesh object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>the vertex number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>v</em>&nbsp;</td><td>the vertex coordinate value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61c3d57d0734a43eb237764af7ec0d95"></a><!-- doxytag: member="sxsdk::loader_interface::set_transformation" ref="a61c3d57d0734a43eb237764af7ec0d95" args="(const sx::mat&lt; float, 4 &gt; &amp;t, void *aux=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sxsdk::loader_interface::set_transformation </td>
          <td>(</td>
          <td class="paramtype">const sx::mat&lt; float, 4 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>aux</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Overridable. When the current object is the top portion of an extruded object, the transformation matrix that represents the extrusion is passed as the parameter. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>t</em>&nbsp;</td><td>The transformation matrix that represents the extrusion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="loaderinterface_8h_source.html">loaderinterface.h</a></li>
</ul>
</div>
<br><br>
<hr>
<div align="center">Copyright &copy; e frontier, Inc. All rights reserved.</div>
</body></html>
